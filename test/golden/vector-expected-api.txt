module Data.Vector where
  (!) :: forall a. Vector a -> GHC.Types.Int -> a
  (!?) :: forall a. Vector a -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: forall a. Vector a -> Vector a -> Vector a
  (//) :: forall a. Vector a -> [(GHC.Types.Int, a)] -> Vector a
  type role MVector nominal representational
  type MVector :: * -> * -> *
  data MVector s a = Data.Vector.Mutable.MVector {Data.Vector.Mutable._offset :: {-# UNPACK #-}GHC.Types.Int, Data.Vector.Mutable._size :: {-# UNPACK #-}GHC.Types.Int, Data.Vector.Mutable._array :: {-# UNPACK #-}(Data.Primitive.Array.MutableArray s a)}
  type Vector :: * -> *
  data Vector a = Data.Vector.Vector {-# UNPACK #-}GHC.Types.Int {-# UNPACK #-}GHC.Types.Int {-# UNPACK #-}(Data.Primitive.Array.Array a)
  accum :: forall a b. (a -> b -> a) -> Vector a -> [(GHC.Types.Int, b)] -> Vector a
  accumulate :: forall a b. (a -> b -> a) -> Vector a -> Vector (GHC.Types.Int, b) -> Vector a
  accumulate_ :: forall a b. (a -> b -> a) -> Vector a -> Vector GHC.Types.Int -> Vector b -> Vector a
  all :: forall a. (a -> GHC.Types.Bool) -> Vector a -> GHC.Types.Bool
  and :: Vector GHC.Types.Bool -> GHC.Types.Bool
  any :: forall a. (a -> GHC.Types.Bool) -> Vector a -> GHC.Types.Bool
  backpermute :: forall a. Vector a -> Vector GHC.Types.Int -> Vector a
  break :: forall a. (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  catMaybes :: forall a. Vector (GHC.Maybe.Maybe a) -> Vector a
  cmpBy :: forall a b. (a -> b -> GHC.Types.Ordering) -> Vector a -> Vector b -> GHC.Types.Ordering
  concat :: forall a. [Vector a] -> Vector a
  concatMap :: forall a b. (a -> Vector b) -> Vector a -> Vector b
  cons :: forall a. a -> Vector a -> Vector a
  constructN :: forall a. GHC.Types.Int -> (Vector a -> a) -> Vector a
  constructrN :: forall a. GHC.Types.Int -> (Vector a -> a) -> Vector a
  convert :: forall (v :: * -> *) a (w :: * -> *). (Data.Vector.Generic.Base.Vector v a, Data.Vector.Generic.Base.Vector w a) => v a -> w a
  copy :: forall (m :: * -> *) a. Control.Monad.Primitive.PrimMonad m => MVector (Control.Monad.Primitive.PrimState m) a -> Vector a -> m ()
  create :: forall a. (forall s. GHC.ST.ST s (MVector s a)) -> Vector a
  createT :: forall (f :: * -> *) a. Data.Traversable.Traversable f => (forall s. GHC.ST.ST s (f (MVector s a))) -> f (Vector a)
  drop :: forall a. GHC.Types.Int -> Vector a -> Vector a
  dropWhile :: forall a. (a -> GHC.Types.Bool) -> Vector a -> Vector a
  elem :: forall a. GHC.Classes.Eq a => a -> Vector a -> GHC.Types.Bool
  elemIndex :: forall a. GHC.Classes.Eq a => a -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  elemIndices :: forall a. GHC.Classes.Eq a => a -> Vector a -> Vector GHC.Types.Int
  empty :: forall a. Vector a
  enumFromN :: forall a. GHC.Num.Num a => a -> GHC.Types.Int -> Vector a
  enumFromStepN :: forall a. GHC.Num.Num a => a -> a -> GHC.Types.Int -> Vector a
  enumFromThenTo :: forall a. GHC.Enum.Enum a => a -> a -> a -> Vector a
  enumFromTo :: forall a. GHC.Enum.Enum a => a -> a -> Vector a
  eqBy :: forall a b. (a -> b -> GHC.Types.Bool) -> Vector a -> Vector b -> GHC.Types.Bool
  filter :: forall a. (a -> GHC.Types.Bool) -> Vector a -> Vector a
  filterM :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Vector a -> m (Vector a)
  find :: forall a. (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe a
  findIndex :: forall a. (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  findIndexR :: forall a. (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  findIndices :: forall a. (a -> GHC.Types.Bool) -> Vector a -> Vector GHC.Types.Int
  fold1M :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> m a) -> Vector a -> m a
  fold1M' :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> m a) -> Vector a -> m a
  fold1M'_ :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> m a) -> Vector a -> m ()
  fold1M_ :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> m a) -> Vector a -> m ()
  foldM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Vector b -> m a
  foldM' :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Vector b -> m a
  foldM'_ :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Vector b -> m ()
  foldM_ :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Vector b -> m ()
  foldMap :: forall m a. GHC.Base.Monoid m => (a -> m) -> Vector a -> m
  foldMap' :: forall m a. GHC.Base.Monoid m => (a -> m) -> Vector a -> m
  foldl :: forall a b. (a -> b -> a) -> a -> Vector b -> a
  foldl' :: forall a b. (a -> b -> a) -> a -> Vector b -> a
  foldl1 :: forall a. (a -> a -> a) -> Vector a -> a
  foldl1' :: forall a. (a -> a -> a) -> Vector a -> a
  foldr :: forall a b. (a -> b -> b) -> b -> Vector a -> b
  foldr' :: forall a b. (a -> b -> b) -> b -> Vector a -> b
  foldr1 :: forall a. (a -> a -> a) -> Vector a -> a
  foldr1' :: forall a. (a -> a -> a) -> Vector a -> a
  forM :: forall (m :: * -> *) a b. GHC.Base.Monad m => Vector a -> (a -> m b) -> m (Vector b)
  forM_ :: forall (m :: * -> *) a b. GHC.Base.Monad m => Vector a -> (a -> m b) -> m ()
  force :: forall a. Vector a -> Vector a
  freeze :: forall (m :: * -> *) a. Control.Monad.Primitive.PrimMonad m => MVector (Control.Monad.Primitive.PrimState m) a -> m (Vector a)
  fromArray :: forall a. Data.Primitive.Array.Array a -> Vector a
  fromList :: forall a. [a] -> Vector a
  fromListN :: forall a. GHC.Types.Int -> [a] -> Vector a
  generate :: forall a. GHC.Types.Int -> (GHC.Types.Int -> a) -> Vector a
  generateM :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> (GHC.Types.Int -> m a) -> m (Vector a)
  group :: forall a. GHC.Classes.Eq a => Vector a -> [Vector a]
  groupBy :: forall a. (a -> a -> GHC.Types.Bool) -> Vector a -> [Vector a]
  head :: forall a. Vector a -> a
  headM :: forall (m :: * -> *) a. GHC.Base.Monad m => Vector a -> m a
  ifilter :: forall a. (GHC.Types.Int -> a -> GHC.Types.Bool) -> Vector a -> Vector a
  ifoldM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m a
  ifoldM' :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m a
  ifoldM'_ :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m ()
  ifoldM_ :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m ()
  ifoldl :: forall a b. (a -> GHC.Types.Int -> b -> a) -> a -> Vector b -> a
  ifoldl' :: forall a b. (a -> GHC.Types.Int -> b -> a) -> a -> Vector b -> a
  ifoldr :: forall a b. (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> b
  ifoldr' :: forall a b. (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> b
  iforM :: forall (m :: * -> *) a b. GHC.Base.Monad m => Vector a -> (GHC.Types.Int -> a -> m b) -> m (Vector b)
  iforM_ :: forall (m :: * -> *) a b. GHC.Base.Monad m => Vector a -> (GHC.Types.Int -> a -> m b) -> m ()
  imap :: forall a b. (GHC.Types.Int -> a -> b) -> Vector a -> Vector b
  imapM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (GHC.Types.Int -> a -> m b) -> Vector a -> m (Vector b)
  imapM_ :: forall (m :: * -> *) a b. GHC.Base.Monad m => (GHC.Types.Int -> a -> m b) -> Vector a -> m ()
  imapMaybe :: forall a b. (GHC.Types.Int -> a -> GHC.Maybe.Maybe b) -> Vector a -> Vector b
  imapMaybeM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (GHC.Types.Int -> a -> m (GHC.Maybe.Maybe b)) -> Vector a -> m (Vector b)
  indexM :: forall (m :: * -> *) a. GHC.Base.Monad m => Vector a -> GHC.Types.Int -> m a
  indexed :: forall a. Vector a -> Vector (GHC.Types.Int, a)
  init :: forall a. Vector a -> Vector a
  iscanl :: forall a b. (GHC.Types.Int -> a -> b -> a) -> a -> Vector b -> Vector a
  iscanl' :: forall a b. (GHC.Types.Int -> a -> b -> a) -> a -> Vector b -> Vector a
  iscanr :: forall a b. (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> Vector b
  iscanr' :: forall a b. (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> Vector b
  iterateN :: forall a. GHC.Types.Int -> (a -> a) -> a -> Vector a
  iterateNM :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> (a -> m a) -> a -> m (Vector a)
  izipWith :: forall a b c. (GHC.Types.Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c
  izipWith3 :: forall a b c d. (GHC.Types.Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
  izipWith4 :: forall a b c d e. (GHC.Types.Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
  izipWith5 :: forall a b c d e f. (GHC.Types.Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
  izipWith6 :: forall a b c d e f g. (GHC.Types.Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
  izipWithM :: forall (m :: * -> *) a b c. GHC.Base.Monad m => (GHC.Types.Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
  izipWithM_ :: forall (m :: * -> *) a b c. GHC.Base.Monad m => (GHC.Types.Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()
  last :: forall a. Vector a -> a
  lastM :: forall (m :: * -> *) a. GHC.Base.Monad m => Vector a -> m a
  length :: forall a. Vector a -> GHC.Types.Int
  map :: forall a b. (a -> b) -> Vector a -> Vector b
  mapM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> m b) -> Vector a -> m (Vector b)
  mapM_ :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> m b) -> Vector a -> m ()
  mapMaybe :: forall a b. (a -> GHC.Maybe.Maybe b) -> Vector a -> Vector b
  mapMaybeM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> m (GHC.Maybe.Maybe b)) -> Vector a -> m (Vector b)
  maxIndex :: forall a. GHC.Classes.Ord a => Vector a -> GHC.Types.Int
  maxIndexBy :: forall a. (a -> a -> GHC.Types.Ordering) -> Vector a -> GHC.Types.Int
  maximum :: forall a. GHC.Classes.Ord a => Vector a -> a
  maximumBy :: forall a. (a -> a -> GHC.Types.Ordering) -> Vector a -> a
  maximumOn :: forall b a. GHC.Classes.Ord b => (a -> b) -> Vector a -> a
  minIndex :: forall a. GHC.Classes.Ord a => Vector a -> GHC.Types.Int
  minIndexBy :: forall a. (a -> a -> GHC.Types.Ordering) -> Vector a -> GHC.Types.Int
  minimum :: forall a. GHC.Classes.Ord a => Vector a -> a
  minimumBy :: forall a. (a -> a -> GHC.Types.Ordering) -> Vector a -> a
  minimumOn :: forall b a. GHC.Classes.Ord b => (a -> b) -> Vector a -> a
  modify :: forall a. (forall s. MVector s a -> GHC.ST.ST s ()) -> Vector a -> Vector a
  notElem :: forall a. GHC.Classes.Eq a => a -> Vector a -> GHC.Types.Bool
  null :: forall a. Vector a -> GHC.Types.Bool
  or :: Vector GHC.Types.Bool -> GHC.Types.Bool
  partition :: forall a. (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  partitionWith :: forall a b c. (a -> Data.Either.Either b c) -> Vector a -> (Vector b, Vector c)
  postscanl :: forall a b. (a -> b -> a) -> a -> Vector b -> Vector a
  postscanl' :: forall a b. (a -> b -> a) -> a -> Vector b -> Vector a
  postscanr :: forall a b. (a -> b -> b) -> b -> Vector a -> Vector b
  postscanr' :: forall a b. (a -> b -> b) -> b -> Vector a -> Vector b
  prescanl :: forall a b. (a -> b -> a) -> a -> Vector b -> Vector a
  prescanl' :: forall a b. (a -> b -> a) -> a -> Vector b -> Vector a
  prescanr :: forall a b. (a -> b -> b) -> b -> Vector a -> Vector b
  prescanr' :: forall a b. (a -> b -> b) -> b -> Vector a -> Vector b
  product :: forall a. GHC.Num.Num a => Vector a -> a
  replicate :: forall a. GHC.Types.Int -> a -> Vector a
  replicateM :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> m a -> m (Vector a)
  reverse :: forall a. Vector a -> Vector a
  scanl :: forall a b. (a -> b -> a) -> a -> Vector b -> Vector a
  scanl' :: forall a b. (a -> b -> a) -> a -> Vector b -> Vector a
  scanl1 :: forall a. (a -> a -> a) -> Vector a -> Vector a
  scanl1' :: forall a. (a -> a -> a) -> Vector a -> Vector a
  scanr :: forall a b. (a -> b -> b) -> b -> Vector a -> Vector b
  scanr' :: forall a b. (a -> b -> b) -> b -> Vector a -> Vector b
  scanr1 :: forall a. (a -> a -> a) -> Vector a -> Vector a
  scanr1' :: forall a. (a -> a -> a) -> Vector a -> Vector a
  sequence :: forall (m :: * -> *) a. GHC.Base.Monad m => Vector (m a) -> m (Vector a)
  sequence_ :: forall (m :: * -> *) a. GHC.Base.Monad m => Vector (m a) -> m ()
  singleton :: forall a. a -> Vector a
  slice :: forall a. GHC.Types.Int -> GHC.Types.Int -> Vector a -> Vector a
  snoc :: forall a. Vector a -> a -> Vector a
  span :: forall a. (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  splitAt :: forall a. GHC.Types.Int -> Vector a -> (Vector a, Vector a)
  sum :: forall a. GHC.Num.Num a => Vector a -> a
  tail :: forall a. Vector a -> Vector a
  take :: forall a. GHC.Types.Int -> Vector a -> Vector a
  takeWhile :: forall a. (a -> GHC.Types.Bool) -> Vector a -> Vector a
  thaw :: forall (m :: * -> *) a. Control.Monad.Primitive.PrimMonad m => Vector a -> m (MVector (Control.Monad.Primitive.PrimState m) a)
  toArray :: forall a. Vector a -> Data.Primitive.Array.Array a
  toArraySlice :: forall a. Vector a -> (Data.Primitive.Array.Array a, GHC.Types.Int, GHC.Types.Int)
  toList :: forall a. Vector a -> [a]
  uncons :: forall a. Vector a -> GHC.Maybe.Maybe (a, Vector a)
  unfoldr :: forall b a. (b -> GHC.Maybe.Maybe (a, b)) -> b -> Vector a
  unfoldrExactN :: forall b a. GHC.Types.Int -> (b -> (a, b)) -> b -> Vector a
  unfoldrExactNM :: forall (m :: * -> *) b a. GHC.Base.Monad m => GHC.Types.Int -> (b -> m (a, b)) -> b -> m (Vector a)
  unfoldrM :: forall (m :: * -> *) b a. GHC.Base.Monad m => (b -> m (GHC.Maybe.Maybe (a, b))) -> b -> m (Vector a)
  unfoldrN :: forall b a. GHC.Types.Int -> (b -> GHC.Maybe.Maybe (a, b)) -> b -> Vector a
  unfoldrNM :: forall (m :: * -> *) b a. GHC.Base.Monad m => GHC.Types.Int -> (b -> m (GHC.Maybe.Maybe (a, b))) -> b -> m (Vector a)
  uniq :: forall a. GHC.Classes.Eq a => Vector a -> Vector a
  unsafeAccum :: forall a b. (a -> b -> a) -> Vector a -> [(GHC.Types.Int, b)] -> Vector a
  unsafeAccumulate :: forall a b. (a -> b -> a) -> Vector a -> Vector (GHC.Types.Int, b) -> Vector a
  unsafeAccumulate_ :: forall a b. (a -> b -> a) -> Vector a -> Vector GHC.Types.Int -> Vector b -> Vector a
  unsafeBackpermute :: forall a. Vector a -> Vector GHC.Types.Int -> Vector a
  unsafeCopy :: forall (m :: * -> *) a. Control.Monad.Primitive.PrimMonad m => MVector (Control.Monad.Primitive.PrimState m) a -> Vector a -> m ()
  unsafeDrop :: forall a. GHC.Types.Int -> Vector a -> Vector a
  unsafeFreeze :: forall (m :: * -> *) a. Control.Monad.Primitive.PrimMonad m => MVector (Control.Monad.Primitive.PrimState m) a -> m (Vector a)
  unsafeFromArraySlice :: forall a. Data.Primitive.Array.Array a -> GHC.Types.Int -> GHC.Types.Int -> Vector a
  unsafeHead :: forall a. Vector a -> a
  unsafeHeadM :: forall (m :: * -> *) a. GHC.Base.Monad m => Vector a -> m a
  unsafeIndex :: forall a. Vector a -> GHC.Types.Int -> a
  unsafeIndexM :: forall (m :: * -> *) a. GHC.Base.Monad m => Vector a -> GHC.Types.Int -> m a
  unsafeInit :: forall a. Vector a -> Vector a
  unsafeLast :: forall a. Vector a -> a
  unsafeLastM :: forall (m :: * -> *) a. GHC.Base.Monad m => Vector a -> m a
  unsafeSlice :: forall a. GHC.Types.Int -> GHC.Types.Int -> Vector a -> Vector a
  unsafeTail :: forall a. Vector a -> Vector a
  unsafeTake :: forall a. GHC.Types.Int -> Vector a -> Vector a
  unsafeThaw :: forall (m :: * -> *) a. Control.Monad.Primitive.PrimMonad m => Vector a -> m (MVector (Control.Monad.Primitive.PrimState m) a)
  unsafeUpd :: forall a. Vector a -> [(GHC.Types.Int, a)] -> Vector a
  unsafeUpdate :: forall a. Vector a -> Vector (GHC.Types.Int, a) -> Vector a
  unsafeUpdate_ :: forall a. Vector a -> Vector GHC.Types.Int -> Vector a -> Vector a
  unsnoc :: forall a. Vector a -> GHC.Maybe.Maybe (Vector a, a)
  unstablePartition :: forall a. (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  unzip :: forall a b. Vector (a, b) -> (Vector a, Vector b)
  unzip3 :: forall a b c. Vector (a, b, c) -> (Vector a, Vector b, Vector c)
  unzip4 :: forall a b c d. Vector (a, b, c, d) -> (Vector a, Vector b, Vector c, Vector d)
  unzip5 :: forall a b c d e. Vector (a, b, c, d, e) -> (Vector a, Vector b, Vector c, Vector d, Vector e)
  unzip6 :: forall a b c d e f. Vector (a, b, c, d, e, f) -> (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)
  update :: forall a. Vector a -> Vector (GHC.Types.Int, a) -> Vector a
  update_ :: forall a. Vector a -> Vector GHC.Types.Int -> Vector a -> Vector a
  zip :: forall a b. Vector a -> Vector b -> Vector (a, b)
  zip3 :: forall a b c. Vector a -> Vector b -> Vector c -> Vector (a, b, c)
  zip4 :: forall a b c d. Vector a -> Vector b -> Vector c -> Vector d -> Vector (a, b, c, d)
  zip5 :: forall a b c d e. Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector (a, b, c, d, e)
  zip6 :: forall a b c d e f. Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector (a, b, c, d, e, f)
  zipWith :: forall a b c. (a -> b -> c) -> Vector a -> Vector b -> Vector c
  zipWith3 :: forall a b c d. (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
  zipWith4 :: forall a b c d e. (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
  zipWith5 :: forall a b c d e f. (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
  zipWith6 :: forall a b c d e f g. (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
  zipWithM :: forall (m :: * -> *) a b c. GHC.Base.Monad m => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
  zipWithM_ :: forall (m :: * -> *) a b c. GHC.Base.Monad m => (a -> b -> m c) -> Vector a -> Vector b -> m ()

module Data.Vector.Fusion.Bundle where
  (!!) :: forall (v :: * -> *) a. Bundle v a -> GHC.Types.Int -> a
  (!?) :: forall (v :: * -> *) a. Bundle v a -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: forall (v :: * -> *) a. Bundle v a -> Bundle v a -> Bundle v a
  type Bundle :: (* -> *) -> * -> *
  type Bundle = Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id :: (* -> *) -> * -> *
  type role Chunk nominal nominal
  type Chunk :: (* -> *) -> * -> *
  data Chunk v a = Chunk GHC.Types.Int (forall (m :: * -> *). (Control.Monad.Primitive.PrimMonad m, Data.Vector.Generic.Base.Vector v a) => Data.Vector.Generic.Base.Mutable v (Control.Monad.Primitive.PrimState m) a -> m ())
  type MBundle :: (* -> *) -> (* -> *) -> * -> *
  type MBundle = Data.Vector.Fusion.Bundle.Monadic.Bundle :: (* -> *) -> (* -> *) -> * -> *
  type Step :: * -> * -> *
  data Step s a where
    Yield :: forall a s. a -> s -> Step s a
    Skip :: forall s a. s -> Step s a
    Done :: forall s a. Step s a
  and :: forall (v :: * -> *). Bundle v GHC.Types.Bool -> GHC.Types.Bool
  cmp :: forall a (v :: * -> *). GHC.Classes.Ord a => Bundle v a -> Bundle v a -> GHC.Types.Ordering
  cmpBy :: forall a b (v :: * -> *). (a -> b -> GHC.Types.Ordering) -> Bundle v a -> Bundle v b -> GHC.Types.Ordering
  concatMap :: forall a (v :: * -> *) b. (a -> Bundle v b) -> Bundle v a -> Bundle v b
  concatVectors :: forall (v :: * -> *) a (u :: * -> *). Data.Vector.Generic.Base.Vector v a => Bundle u (v a) -> Bundle v a
  cons :: forall a (v :: * -> *). a -> Bundle v a -> Bundle v a
  drop :: forall (v :: * -> *) a. GHC.Types.Int -> Bundle v a -> Bundle v a
  dropWhile :: forall a (v :: * -> *). (a -> GHC.Types.Bool) -> Bundle v a -> Bundle v a
  elem :: forall a (v :: * -> *). GHC.Classes.Eq a => a -> Bundle v a -> GHC.Types.Bool
  empty :: forall (v :: * -> *) a. Bundle v a
  enumFromStepN :: forall a (v :: * -> *). GHC.Num.Num a => a -> a -> GHC.Types.Int -> Bundle v a
  enumFromThenTo :: forall a (v :: * -> *). GHC.Enum.Enum a => a -> a -> a -> Bundle v a
  enumFromTo :: forall a (v :: * -> *). GHC.Enum.Enum a => a -> a -> Bundle v a
  eq :: forall a (v :: * -> *). GHC.Classes.Eq a => Bundle v a -> Bundle v a -> GHC.Types.Bool
  eqBy :: forall a b (v :: * -> *). (a -> b -> GHC.Types.Bool) -> Bundle v a -> Bundle v b -> GHC.Types.Bool
  filter :: forall a (v :: * -> *). (a -> GHC.Types.Bool) -> Bundle v a -> Bundle v a
  filterM :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Bundle v a -> Data.Vector.Fusion.Bundle.Monadic.Bundle m v a
  find :: forall a (v :: * -> *). (a -> GHC.Types.Bool) -> Bundle v a -> GHC.Maybe.Maybe a
  findIndex :: forall a (v :: * -> *). (a -> GHC.Types.Bool) -> Bundle v a -> GHC.Maybe.Maybe GHC.Types.Int
  flatten :: forall a s b (v :: * -> *). (a -> s) -> (s -> Step s b) -> Data.Vector.Fusion.Bundle.Size.Size -> Bundle v a -> Bundle v b
  fold1M :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> m a) -> Bundle v a -> m a
  fold1M' :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> m a) -> Bundle v a -> m a
  foldM :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle v b -> m a
  foldM' :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle v b -> m a
  foldl :: forall a b (v :: * -> *). (a -> b -> a) -> a -> Bundle v b -> a
  foldl' :: forall a b (v :: * -> *). (a -> b -> a) -> a -> Bundle v b -> a
  foldl1 :: forall a (v :: * -> *). (a -> a -> a) -> Bundle v a -> a
  foldl1' :: forall a (v :: * -> *). (a -> a -> a) -> Bundle v a -> a
  foldr :: forall a b (v :: * -> *). (a -> b -> b) -> b -> Bundle v a -> b
  foldr1 :: forall a (v :: * -> *). (a -> a -> a) -> Bundle v a -> a
  fromList :: forall a (v :: * -> *). [a] -> Bundle v a
  fromListN :: forall a (v :: * -> *). GHC.Types.Int -> [a] -> Bundle v a
  fromVector :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => v a -> Bundle v a
  fromVectors :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => [v a] -> Bundle v a
  generate :: forall a (v :: * -> *). GHC.Types.Int -> (GHC.Types.Int -> a) -> Bundle v a
  head :: forall (v :: * -> *) a. Bundle v a -> a
  indexed :: forall (v :: * -> *) a. Bundle v a -> Bundle v (GHC.Types.Int, a)
  indexedR :: forall (v :: * -> *) a. GHC.Types.Int -> Bundle v a -> Bundle v (GHC.Types.Int, a)
  init :: forall (v :: * -> *) a. Bundle v a -> Bundle v a
  inplace :: forall a b (v :: * -> *). (forall (m :: * -> *). GHC.Base.Monad m => Data.Stream.Monadic.Stream m a -> Data.Stream.Monadic.Stream m b) -> (Data.Vector.Fusion.Bundle.Size.Size -> Data.Vector.Fusion.Bundle.Size.Size) -> Bundle v a -> Bundle v b
  iterateN :: forall a (v :: * -> *). GHC.Types.Int -> (a -> a) -> a -> Bundle v a
  last :: forall (v :: * -> *) a. Bundle v a -> a
  length :: forall (v :: * -> *) a. Bundle v a -> GHC.Types.Int
  lift :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v a -> Data.Vector.Fusion.Bundle.Monadic.Bundle m v a
  map :: forall a b (v :: * -> *). (a -> b) -> Bundle v a -> Bundle v b
  mapM :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> m b) -> Bundle v a -> Data.Vector.Fusion.Bundle.Monadic.Bundle m v b
  mapM_ :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> m b) -> Bundle v a -> m ()
  mapMaybeM :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> m (GHC.Maybe.Maybe b)) -> Bundle v a -> Data.Vector.Fusion.Bundle.Monadic.Bundle m v b
  notElem :: forall a (v :: * -> *). GHC.Classes.Eq a => a -> Bundle v a -> GHC.Types.Bool
  null :: forall (v :: * -> *) a. Bundle v a -> GHC.Types.Bool
  or :: forall (v :: * -> *). Bundle v GHC.Types.Bool -> GHC.Types.Bool
  postscanl :: forall a b (v :: * -> *). (a -> b -> a) -> a -> Bundle v b -> Bundle v a
  postscanl' :: forall a b (v :: * -> *). (a -> b -> a) -> a -> Bundle v b -> Bundle v a
  prescanl :: forall a b (v :: * -> *). (a -> b -> a) -> a -> Bundle v b -> Bundle v a
  prescanl' :: forall a b (v :: * -> *). (a -> b -> a) -> a -> Bundle v b -> Bundle v a
  reVector :: forall (u :: * -> *) a (v :: * -> *). Bundle u a -> Bundle v a
  replicate :: forall a (v :: * -> *). GHC.Types.Int -> a -> Bundle v a
  scanl :: forall a b (v :: * -> *). (a -> b -> a) -> a -> Bundle v b -> Bundle v a
  scanl' :: forall a b (v :: * -> *). (a -> b -> a) -> a -> Bundle v b -> Bundle v a
  scanl1 :: forall a (v :: * -> *). (a -> a -> a) -> Bundle v a -> Bundle v a
  scanl1' :: forall a (v :: * -> *). (a -> a -> a) -> Bundle v a -> Bundle v a
  singleton :: forall a (v :: * -> *). a -> Bundle v a
  size :: forall (v :: * -> *) a. Bundle v a -> Data.Vector.Fusion.Bundle.Size.Size
  sized :: forall (v :: * -> *) a. Bundle v a -> Data.Vector.Fusion.Bundle.Size.Size -> Bundle v a
  slice :: forall (v :: * -> *) a. GHC.Types.Int -> GHC.Types.Int -> Bundle v a -> Bundle v a
  snoc :: forall (v :: * -> *) a. Bundle v a -> a -> Bundle v a
  tail :: forall (v :: * -> *) a. Bundle v a -> Bundle v a
  take :: forall (v :: * -> *) a. GHC.Types.Int -> Bundle v a -> Bundle v a
  takeWhile :: forall a (v :: * -> *). (a -> GHC.Types.Bool) -> Bundle v a -> Bundle v a
  toList :: forall (v :: * -> *) a. Bundle v a -> [a]
  unbox :: forall (v :: * -> *) a. Bundle v (Data.Stream.Monadic.Box a) -> Bundle v a
  unfoldr :: forall s a (v :: * -> *). (s -> GHC.Maybe.Maybe (a, s)) -> s -> Bundle v a
  unfoldrExactN :: forall s a (v :: * -> *). GHC.Types.Int -> (s -> (a, s)) -> s -> Bundle v a
  unfoldrN :: forall s a (v :: * -> *). GHC.Types.Int -> (s -> GHC.Maybe.Maybe (a, s)) -> s -> Bundle v a
  unsafeFromList :: forall a (v :: * -> *). Data.Vector.Fusion.Bundle.Size.Size -> [a] -> Bundle v a
  zip :: forall (v :: * -> *) a b. Bundle v a -> Bundle v b -> Bundle v (a, b)
  zip3 :: forall (v :: * -> *) a b c. Bundle v a -> Bundle v b -> Bundle v c -> Bundle v (a, b, c)
  zip4 :: forall (v :: * -> *) a b c d. Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v (a, b, c, d)
  zip5 :: forall (v :: * -> *) a b c d e. Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v (a, b, c, d, e)
  zip6 :: forall (v :: * -> *) a b c d e f. Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v f -> Bundle v (a, b, c, d, e, f)
  zipWith :: forall a b c (v :: * -> *). (a -> b -> c) -> Bundle v a -> Bundle v b -> Bundle v c
  zipWith3 :: forall a b c d (v :: * -> *). (a -> b -> c -> d) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d
  zipWith4 :: forall a b c d e (v :: * -> *). (a -> b -> c -> d -> e) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e
  zipWith5 :: forall a b c d e f (v :: * -> *). (a -> b -> c -> d -> e -> f) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v f
  zipWith6 :: forall a b c d e f g (v :: * -> *). (a -> b -> c -> d -> e -> f -> g) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v f -> Bundle v g
  zipWithM :: forall (m :: * -> *) a b c (v :: * -> *). GHC.Base.Monad m => (a -> b -> m c) -> Bundle v a -> Bundle v b -> Data.Vector.Fusion.Bundle.Monadic.Bundle m v c
  zipWithM_ :: forall (m :: * -> *) a b c (v :: * -> *). GHC.Base.Monad m => (a -> b -> m c) -> Bundle v a -> Bundle v b -> m ()

module Data.Vector.Fusion.Bundle.Monadic where
  (!!) :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> GHC.Types.Int -> m a
  (!?) :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> GHC.Types.Int -> m (GHC.Maybe.Maybe a)
  (++) :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> Bundle m v a -> Bundle m v a
  type role Bundle representational nominal nominal
  type Bundle :: (* -> *) -> (* -> *) -> * -> *
  data Bundle m v a = Bundle {sElems :: Data.Stream.Monadic.Stream m a, sChunks :: Data.Stream.Monadic.Stream m (Chunk v a), sVector :: GHC.Maybe.Maybe (v a), sSize :: Data.Vector.Fusion.Bundle.Size.Size}
  type role Chunk nominal nominal
  type Chunk :: (* -> *) -> * -> *
  data Chunk v a = Chunk GHC.Types.Int (forall (m :: * -> *). (Control.Monad.Primitive.PrimMonad m, Data.Vector.Generic.Base.Vector v a) => Data.Vector.Generic.Base.Mutable v (Control.Monad.Primitive.PrimState m) a -> m ())
  and :: forall (m :: * -> *) (v :: * -> *). GHC.Base.Monad m => Bundle m v GHC.Types.Bool -> m GHC.Types.Bool
  chunks :: forall (m :: * -> *) (v :: * -> *) a. Bundle m v a -> Data.Stream.Monadic.Stream m (Chunk v a)
  cmpBy :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> GHC.Types.Ordering) -> Bundle m v a -> Bundle m v b -> m GHC.Types.Ordering
  concatMap :: forall (m :: * -> *) a (v :: * -> *) b. GHC.Base.Monad m => (a -> Bundle m v b) -> Bundle m v a -> Bundle m v b
  concatMapM :: forall (m :: * -> *) a (v :: * -> *) b. GHC.Base.Monad m => (a -> m (Bundle m v b)) -> Bundle m v a -> Bundle m v b
  concatVectors :: forall (m :: * -> *) (v :: * -> *) a (u :: * -> *). (GHC.Base.Monad m, Data.Vector.Generic.Base.Vector v a) => Bundle m u (v a) -> Bundle m v a
  cons :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => a -> Bundle m v a -> Bundle m v a
  drop :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> Bundle m v a -> Bundle m v a
  dropWhile :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> GHC.Types.Bool) -> Bundle m v a -> Bundle m v a
  dropWhileM :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Bundle m v a -> Bundle m v a
  elem :: forall (m :: * -> *) a (v :: * -> *). (GHC.Base.Monad m, GHC.Classes.Eq a) => a -> Bundle m v a -> m GHC.Types.Bool
  elements :: forall (m :: * -> *) (v :: * -> *) a. Bundle m v a -> Data.Stream.Monadic.Stream m a
  empty :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a
  enumFromStepN :: forall a (m :: * -> *) (v :: * -> *). (GHC.Num.Num a, GHC.Base.Monad m) => a -> a -> GHC.Types.Int -> Bundle m v a
  enumFromThenTo :: forall a (m :: * -> *) (v :: * -> *). (GHC.Enum.Enum a, GHC.Base.Monad m) => a -> a -> a -> Bundle m v a
  enumFromTo :: forall a (m :: * -> *) (v :: * -> *). (GHC.Enum.Enum a, GHC.Base.Monad m) => a -> a -> Bundle m v a
  eqBy :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> GHC.Types.Bool) -> Bundle m v a -> Bundle m v b -> m GHC.Types.Bool
  filter :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> GHC.Types.Bool) -> Bundle m v a -> Bundle m v a
  filterM :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Bundle m v a -> Bundle m v a
  find :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> GHC.Types.Bool) -> Bundle m v a -> m (GHC.Maybe.Maybe a)
  findIndex :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> GHC.Types.Bool) -> Bundle m v a -> m (GHC.Maybe.Maybe GHC.Types.Int)
  findIndexM :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Bundle m v a -> m (GHC.Maybe.Maybe GHC.Types.Int)
  findM :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Bundle m v a -> m (GHC.Maybe.Maybe a)
  flatten :: forall (m :: * -> *) a s b (v :: * -> *). GHC.Base.Monad m => (a -> m s) -> (s -> m (Data.Stream.Monadic.Step s b)) -> Data.Vector.Fusion.Bundle.Size.Size -> Bundle m v a -> Bundle m v b
  fold1M :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> m a) -> Bundle m v a -> m a
  fold1M' :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> m a) -> Bundle m v a -> m a
  foldM :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a
  foldM' :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a
  foldl :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> a) -> a -> Bundle m v b -> m a
  foldl' :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> a) -> a -> Bundle m v b -> m a
  foldl1 :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> a) -> Bundle m v a -> m a
  foldl1' :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> a) -> Bundle m v a -> m a
  foldl1M :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> m a) -> Bundle m v a -> m a
  foldl1M' :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> m a) -> Bundle m v a -> m a
  foldlM :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a
  foldlM' :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a
  foldr :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> b) -> b -> Bundle m v a -> m b
  foldr1 :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> a) -> Bundle m v a -> m a
  foldr1M :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> m a) -> Bundle m v a -> m a
  foldrM :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m b) -> b -> Bundle m v a -> m b
  fromList :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => [a] -> Bundle m v a
  fromListN :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => GHC.Types.Int -> [a] -> Bundle m v a
  fromStream :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => Data.Stream.Monadic.Stream m a -> Data.Vector.Fusion.Bundle.Size.Size -> Bundle m v a
  fromVector :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Data.Vector.Generic.Base.Vector v a) => v a -> Bundle m v a
  fromVectors :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Data.Vector.Generic.Base.Vector v a) => [v a] -> Bundle m v a
  generate :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => GHC.Types.Int -> (GHC.Types.Int -> a) -> Bundle m v a
  generateM :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => GHC.Types.Int -> (GHC.Types.Int -> m a) -> Bundle m v a
  head :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> m a
  indexed :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> Bundle m v (GHC.Types.Int, a)
  indexedR :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> Bundle m v a -> Bundle m v (GHC.Types.Int, a)
  init :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> Bundle m v a
  iterateN :: forall (m :: * -> *) a (u :: * -> *). GHC.Base.Monad m => GHC.Types.Int -> (a -> a) -> a -> Bundle m u a
  iterateNM :: forall (m :: * -> *) a (u :: * -> *). GHC.Base.Monad m => GHC.Types.Int -> (a -> m a) -> a -> Bundle m u a
  last :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> m a
  length :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> m GHC.Types.Int
  lift :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle Data.Vector.Fusion.Util.Id v a -> Bundle m v a
  map :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b) -> Bundle m v a -> Bundle m v b
  mapM :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> m b) -> Bundle m v a -> Bundle m v b
  mapM_ :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> m b) -> Bundle m v a -> m ()
  mapMaybeM :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> m (GHC.Maybe.Maybe b)) -> Bundle m v a -> Bundle m v b
  notElem :: forall (m :: * -> *) a (v :: * -> *). (GHC.Base.Monad m, GHC.Classes.Eq a) => a -> Bundle m v a -> m GHC.Types.Bool
  null :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> m GHC.Types.Bool
  or :: forall (m :: * -> *) (v :: * -> *). GHC.Base.Monad m => Bundle m v GHC.Types.Bool -> m GHC.Types.Bool
  postscanl :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a
  postscanl' :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a
  postscanlM :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a
  postscanlM' :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a
  prescanl :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a
  prescanl' :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a
  prescanlM :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a
  prescanlM' :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a
  reVector :: forall (m :: * -> *) (u :: * -> *) a (v :: * -> *). GHC.Base.Monad m => Bundle m u a -> Bundle m v a
  replicate :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => GHC.Types.Int -> a -> Bundle m v a
  replicateM :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => GHC.Types.Int -> m a -> Bundle m v a
  scanl :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a
  scanl' :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a
  scanl1 :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> a) -> Bundle m v a -> Bundle m v a
  scanl1' :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> a) -> Bundle m v a -> Bundle m v a
  scanl1M :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> m a) -> Bundle m v a -> Bundle m v a
  scanl1M' :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> a -> m a) -> Bundle m v a -> Bundle m v a
  scanlM :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a
  scanlM' :: forall (m :: * -> *) a b (v :: * -> *). GHC.Base.Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a
  singleton :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => a -> Bundle m v a
  size :: forall (m :: * -> *) (v :: * -> *) a. Bundle m v a -> Data.Vector.Fusion.Bundle.Size.Size
  sized :: forall (m :: * -> *) (v :: * -> *) a. Bundle m v a -> Data.Vector.Fusion.Bundle.Size.Size -> Bundle m v a
  slice :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> GHC.Types.Int -> Bundle m v a -> Bundle m v a
  snoc :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> a -> Bundle m v a
  tail :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> Bundle m v a
  take :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> Bundle m v a -> Bundle m v a
  takeWhile :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> GHC.Types.Bool) -> Bundle m v a -> Bundle m v a
  takeWhileM :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Bundle m v a -> Bundle m v a
  toList :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v a -> m [a]
  trans :: forall (m :: * -> *) (m' :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, GHC.Base.Monad m') => (forall z. m z -> m' z) -> Bundle m v a -> Bundle m' v a
  unbox :: forall (m :: * -> *) (v :: * -> *) a. GHC.Base.Monad m => Bundle m v (Data.Stream.Monadic.Box a) -> Bundle m v a
  unfoldr :: forall (m :: * -> *) s a (u :: * -> *). GHC.Base.Monad m => (s -> GHC.Maybe.Maybe (a, s)) -> s -> Bundle m u a
  unfoldrExactN :: forall (m :: * -> *) s a (u :: * -> *). GHC.Base.Monad m => GHC.Types.Int -> (s -> (a, s)) -> s -> Bundle m u a
  unfoldrExactNM :: forall (m :: * -> *) s a (u :: * -> *). GHC.Base.Monad m => GHC.Types.Int -> (s -> m (a, s)) -> s -> Bundle m u a
  unfoldrM :: forall (m :: * -> *) s a (u :: * -> *). GHC.Base.Monad m => (s -> m (GHC.Maybe.Maybe (a, s))) -> s -> Bundle m u a
  unfoldrN :: forall (m :: * -> *) s a (u :: * -> *). GHC.Base.Monad m => GHC.Types.Int -> (s -> GHC.Maybe.Maybe (a, s)) -> s -> Bundle m u a
  unfoldrNM :: forall (m :: * -> *) s a (u :: * -> *). GHC.Base.Monad m => GHC.Types.Int -> (s -> m (GHC.Maybe.Maybe (a, s))) -> s -> Bundle m u a
  unsafeFromList :: forall (m :: * -> *) a (v :: * -> *). GHC.Base.Monad m => Data.Vector.Fusion.Bundle.Size.Size -> [a] -> Bundle m v a
  zip :: forall (m :: * -> *) (v :: * -> *) a b. GHC.Base.Monad m => Bundle m v a -> Bundle m v b -> Bundle m v (a, b)
  zip3 :: forall (m :: * -> *) (v :: * -> *) a b c. GHC.Base.Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v (a, b, c)
  zip4 :: forall (m :: * -> *) (v :: * -> *) a b c d. GHC.Base.Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v (a, b, c, d)
  zip5 :: forall (m :: * -> *) (v :: * -> *) a b c d e. GHC.Base.Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v (a, b, c, d, e)
  zip6 :: forall (m :: * -> *) (v :: * -> *) a b c d e f. GHC.Base.Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f -> Bundle m v (a, b, c, d, e, f)
  zipWith :: forall (m :: * -> *) a b c (v :: * -> *). GHC.Base.Monad m => (a -> b -> c) -> Bundle m v a -> Bundle m v b -> Bundle m v c
  zipWith3 :: forall (m :: * -> *) a b c d (v :: * -> *). GHC.Base.Monad m => (a -> b -> c -> d) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d
  zipWith3M :: forall (m :: * -> *) a b c d (v :: * -> *). GHC.Base.Monad m => (a -> b -> c -> m d) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d
  zipWith4 :: forall (m :: * -> *) a b c d e (v :: * -> *). GHC.Base.Monad m => (a -> b -> c -> d -> e) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e
  zipWith4M :: forall (m :: * -> *) a b c d e (v :: * -> *). GHC.Base.Monad m => (a -> b -> c -> d -> m e) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e
  zipWith5 :: forall (m :: * -> *) a b c d e f (v :: * -> *). GHC.Base.Monad m => (a -> b -> c -> d -> e -> f) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f
  zipWith5M :: forall (m :: * -> *) a b c d e f (v :: * -> *). GHC.Base.Monad m => (a -> b -> c -> d -> e -> m f) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f
  zipWith6 :: forall (m :: * -> *) a b c d e f g (v :: * -> *). GHC.Base.Monad m => (a -> b -> c -> d -> e -> f -> g) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f -> Bundle m v g
  zipWith6M :: forall (m :: * -> *) a b c d e f g (v :: * -> *). GHC.Base.Monad m => (a -> b -> c -> d -> e -> f -> m g) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f -> Bundle m v g
  zipWithM :: forall (m :: * -> *) a b c (v :: * -> *). GHC.Base.Monad m => (a -> b -> m c) -> Bundle m v a -> Bundle m v b -> Bundle m v c
  zipWithM_ :: forall (m :: * -> *) a b c (v :: * -> *). GHC.Base.Monad m => (a -> b -> m c) -> Bundle m v a -> Bundle m v b -> m ()

module Data.Vector.Fusion.Bundle.Size where
  type Size :: *
  data Size = Exact {-# UNPACK #-}GHC.Types.Int | Max {-# UNPACK #-}GHC.Types.Int | Unknown
  clampedSubtract :: Size -> Size -> Size
  larger :: Size -> Size -> Size
  lowerBound :: Size -> GHC.Types.Int
  smaller :: Size -> Size -> Size
  smallerThan :: GHC.Types.Int -> Size -> Size
  toMax :: Size -> Size
  upperBound :: Size -> GHC.Maybe.Maybe GHC.Types.Int

module Data.Vector.Fusion.Stream.Monadic where
  (!!) :: forall (m :: * -> *) a. (GHC.Stack.Types.HasCallStack, GHC.Base.Monad m) => Stream m a -> GHC.Types.Int -> m a
  (!?) :: forall (m :: * -> *) a. GHC.Base.Monad m => Stream m a -> GHC.Types.Int -> m (GHC.Maybe.Maybe a)
  (++) :: forall (m :: * -> *) a. GHC.Base.Monad m => Stream m a -> Stream m a -> Stream m a
  type Box :: * -> *
  data Box a = Box {unBox :: a}
  type SPEC :: *
  data SPEC = SPEC | SPEC2
  type Step :: * -> * -> *
  data Step s a where
    Yield :: forall a s. a -> s -> Step s a
    Skip :: forall s a. s -> Step s a
    Done :: forall s a. Step s a
  type role Stream representational nominal
  type Stream :: (* -> *) -> * -> *
  data Stream m a = forall s. Stream (s -> m (Step s a)) s
  and :: forall (m :: * -> *). GHC.Base.Monad m => Stream m GHC.Types.Bool -> m GHC.Types.Bool
  catMaybes :: forall (m :: * -> *) a. GHC.Base.Monad m => Stream m (GHC.Maybe.Maybe a) -> Stream m a
  cmpBy :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> GHC.Types.Ordering) -> Stream m a -> Stream m b -> m GHC.Types.Ordering
  concatMap :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> Stream m b) -> Stream m a -> Stream m b
  concatMapM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> m (Stream m b)) -> Stream m a -> Stream m b
  cons :: forall (m :: * -> *) a. GHC.Base.Monad m => a -> Stream m a -> Stream m a
  drop :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> Stream m a -> Stream m a
  dropWhile :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> GHC.Types.Bool) -> Stream m a -> Stream m a
  dropWhileM :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Stream m a -> Stream m a
  elem :: forall (m :: * -> *) a. (GHC.Base.Monad m, GHC.Classes.Eq a) => a -> Stream m a -> m GHC.Types.Bool
  empty :: forall (m :: * -> *) a. GHC.Base.Monad m => Stream m a
  enumFromStepN :: forall a (m :: * -> *). (GHC.Num.Num a, GHC.Base.Monad m) => a -> a -> GHC.Types.Int -> Stream m a
  enumFromThenTo :: forall a (m :: * -> *). (GHC.Enum.Enum a, GHC.Base.Monad m) => a -> a -> a -> Stream m a
  enumFromTo :: forall a (m :: * -> *). (GHC.Enum.Enum a, GHC.Base.Monad m) => a -> a -> Stream m a
  eqBy :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> GHC.Types.Bool) -> Stream m a -> Stream m b -> m GHC.Types.Bool
  filter :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> GHC.Types.Bool) -> Stream m a -> Stream m a
  filterM :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Stream m a -> Stream m a
  find :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> GHC.Types.Bool) -> Stream m a -> m (GHC.Maybe.Maybe a)
  findIndex :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> GHC.Types.Bool) -> Stream m a -> m (GHC.Maybe.Maybe GHC.Types.Int)
  findIndexM :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Stream m a -> m (GHC.Maybe.Maybe GHC.Types.Int)
  findM :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Stream m a -> m (GHC.Maybe.Maybe a)
  flatten :: forall (m :: * -> *) a s b. GHC.Base.Monad m => (a -> m s) -> (s -> m (Step s b)) -> Stream m a -> Stream m b
  fold1M :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> m a) -> Stream m a -> m a
  fold1M' :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> m a) -> Stream m a -> m a
  foldM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Stream m b -> m a
  foldM' :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Stream m b -> m a
  foldl :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> a) -> a -> Stream m b -> m a
  foldl' :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> a) -> a -> Stream m b -> m a
  foldl1 :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> a) -> Stream m a -> m a
  foldl1' :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> a) -> Stream m a -> m a
  foldl1M :: forall (m :: * -> *) a. (GHC.Stack.Types.HasCallStack, GHC.Base.Monad m) => (a -> a -> m a) -> Stream m a -> m a
  foldl1M' :: forall (m :: * -> *) a. (GHC.Stack.Types.HasCallStack, GHC.Base.Monad m) => (a -> a -> m a) -> Stream m a -> m a
  foldlM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Stream m b -> m a
  foldlM' :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Stream m b -> m a
  foldr :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> b) -> b -> Stream m a -> m b
  foldr1 :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> a) -> Stream m a -> m a
  foldr1M :: forall (m :: * -> *) a. (GHC.Stack.Types.HasCallStack, GHC.Base.Monad m) => (a -> a -> m a) -> Stream m a -> m a
  foldrM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m b) -> b -> Stream m a -> m b
  fromList :: forall (m :: * -> *) a. GHC.Base.Monad m => [a] -> Stream m a
  fromListN :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> [a] -> Stream m a
  generate :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> (GHC.Types.Int -> a) -> Stream m a
  generateM :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> (GHC.Types.Int -> m a) -> Stream m a
  head :: forall (m :: * -> *) a. (GHC.Stack.Types.HasCallStack, GHC.Base.Monad m) => Stream m a -> m a
  indexed :: forall (m :: * -> *) a. GHC.Base.Monad m => Stream m a -> Stream m (GHC.Types.Int, a)
  indexedR :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> Stream m a -> Stream m (GHC.Types.Int, a)
  init :: forall (m :: * -> *) a. (GHC.Stack.Types.HasCallStack, GHC.Base.Monad m) => Stream m a -> Stream m a
  iterateN :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> (a -> a) -> a -> Stream m a
  iterateNM :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> (a -> m a) -> a -> Stream m a
  last :: forall (m :: * -> *) a. (GHC.Stack.Types.HasCallStack, GHC.Base.Monad m) => Stream m a -> m a
  length :: forall (m :: * -> *) a. GHC.Base.Monad m => Stream m a -> m GHC.Types.Int
  liftBox :: forall (m :: * -> *) a. GHC.Base.Monad m => Box a -> m a
  map :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b) -> Stream m a -> Stream m b
  mapM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> m b) -> Stream m a -> Stream m b
  mapM_ :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> m b) -> Stream m a -> m ()
  mapMaybe :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> GHC.Maybe.Maybe b) -> Stream m a -> Stream m b
  mapMaybeM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> m (GHC.Maybe.Maybe b)) -> Stream m a -> Stream m b
  notElem :: forall (m :: * -> *) a. (GHC.Base.Monad m, GHC.Classes.Eq a) => a -> Stream m a -> m GHC.Types.Bool
  null :: forall (m :: * -> *) a. GHC.Base.Monad m => Stream m a -> m GHC.Types.Bool
  or :: forall (m :: * -> *). GHC.Base.Monad m => Stream m GHC.Types.Bool -> m GHC.Types.Bool
  postscanl :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a
  postscanl' :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a
  postscanlM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a
  postscanlM' :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a
  prescanl :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a
  prescanl' :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a
  prescanlM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a
  prescanlM' :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a
  replicate :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> a -> Stream m a
  replicateM :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> m a -> Stream m a
  scanl :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a
  scanl' :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a
  scanl1 :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> a) -> Stream m a -> Stream m a
  scanl1' :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> a) -> Stream m a -> Stream m a
  scanl1M :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> m a) -> Stream m a -> Stream m a
  scanl1M' :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> a -> m a) -> Stream m a -> Stream m a
  scanlM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a
  scanlM' :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a
  singleton :: forall (m :: * -> *) a. GHC.Base.Monad m => a -> Stream m a
  slice :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> GHC.Types.Int -> Stream m a -> Stream m a
  snoc :: forall (m :: * -> *) a. GHC.Base.Monad m => Stream m a -> a -> Stream m a
  tail :: forall (m :: * -> *) a. (GHC.Stack.Types.HasCallStack, GHC.Base.Monad m) => Stream m a -> Stream m a
  take :: forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Types.Int -> Stream m a -> Stream m a
  takeWhile :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> GHC.Types.Bool) -> Stream m a -> Stream m a
  takeWhileM :: forall (m :: * -> *) a. GHC.Base.Monad m => (a -> m GHC.Types.Bool) -> Stream m a -> Stream m a
  toList :: forall (m :: * -> *) a. GHC.Base.Monad m => Stream m a -> m [a]
  trans :: forall (m :: * -> *) (m' :: * -> *) a. (GHC.Base.Monad m, GHC.Base.Monad m') => (forall z. m z -> m' z) -> Stream m a -> Stream m' a
  unbox :: forall (m :: * -> *) a. GHC.Base.Monad m => Stream m (Box a) -> Stream m a
  unfoldr :: forall (m :: * -> *) s a. GHC.Base.Monad m => (s -> GHC.Maybe.Maybe (a, s)) -> s -> Stream m a
  unfoldrExactN :: forall (m :: * -> *) s a. GHC.Base.Monad m => GHC.Types.Int -> (s -> (a, s)) -> s -> Stream m a
  unfoldrExactNM :: forall (m :: * -> *) s a. GHC.Base.Monad m => GHC.Types.Int -> (s -> m (a, s)) -> s -> Stream m a
  unfoldrM :: forall (m :: * -> *) s a. GHC.Base.Monad m => (s -> m (GHC.Maybe.Maybe (a, s))) -> s -> Stream m a
  unfoldrN :: forall (m :: * -> *) s a. GHC.Base.Monad m => GHC.Types.Int -> (s -> GHC.Maybe.Maybe (a, s)) -> s -> Stream m a
  unfoldrNM :: forall (m :: * -> *) s a. GHC.Base.Monad m => GHC.Types.Int -> (s -> m (GHC.Maybe.Maybe (a, s))) -> s -> Stream m a
  uniq :: forall a (m :: * -> *). (GHC.Classes.Eq a, GHC.Base.Monad m) => Stream m a -> Stream m a
  zip :: forall (m :: * -> *) a b. GHC.Base.Monad m => Stream m a -> Stream m b -> Stream m (a, b)
  zip3 :: forall (m :: * -> *) a b c. GHC.Base.Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m (a, b, c)
  zip4 :: forall (m :: * -> *) a b c d. GHC.Base.Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m (a, b, c, d)
  zip5 :: forall (m :: * -> *) a b c d e. GHC.Base.Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m (a, b, c, d, e)
  zip6 :: forall (m :: * -> *) a b c d e f. GHC.Base.Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f -> Stream m (a, b, c, d, e, f)
  zipWith :: forall (m :: * -> *) a b c. GHC.Base.Monad m => (a -> b -> c) -> Stream m a -> Stream m b -> Stream m c
  zipWith3 :: forall (m :: * -> *) a b c d. GHC.Base.Monad m => (a -> b -> c -> d) -> Stream m a -> Stream m b -> Stream m c -> Stream m d
  zipWith3M :: forall (m :: * -> *) a b c d. GHC.Base.Monad m => (a -> b -> c -> m d) -> Stream m a -> Stream m b -> Stream m c -> Stream m d
  zipWith4 :: forall (m :: * -> *) a b c d e. GHC.Base.Monad m => (a -> b -> c -> d -> e) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e
  zipWith4M :: forall (m :: * -> *) a b c d e. GHC.Base.Monad m => (a -> b -> c -> d -> m e) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e
  zipWith5 :: forall (m :: * -> *) a b c d e f. GHC.Base.Monad m => (a -> b -> c -> d -> e -> f) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f
  zipWith5M :: forall (m :: * -> *) a b c d e f. GHC.Base.Monad m => (a -> b -> c -> d -> e -> m f) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f
  zipWith6 :: forall (m :: * -> *) a b c d e f g. GHC.Base.Monad m => (a -> b -> c -> d -> e -> f -> g) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f -> Stream m g
  zipWith6M :: forall (m :: * -> *) a b c d e f g. GHC.Base.Monad m => (a -> b -> c -> d -> e -> f -> m g) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f -> Stream m g
  zipWithM :: forall (m :: * -> *) a b c. GHC.Base.Monad m => (a -> b -> m c) -> Stream m a -> Stream m b -> Stream m c
  zipWithM_ :: forall (m :: * -> *) a b c. GHC.Base.Monad m => (a -> b -> m c) -> Stream m a -> Stream m b -> m ()

module Data.Vector.Fusion.Util where
  type Box :: * -> *
  data Box a = Box {unBox :: a}
  type Id :: * -> *
  newtype Id a = Id {unId :: a}
  delay_inline :: forall a b. (a -> b) -> a -> b
  delayed_min :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  liftBox :: forall (m :: * -> *) a. GHC.Base.Monad m => Box a -> m a

module Data.Vector.Generic where
  (!) :: forall (v :: * -> *) a. (GHC.Stack.Types.HasCallStack, Vector v a) => v a -> GHC.Types.Int -> a
  (!?) :: forall (v :: * -> *) a. Vector v a => v a -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: forall (v :: * -> *) a. Vector v a => v a -> v a -> v a
  (//) :: forall (v :: * -> *) a. Vector v a => v a -> [(GHC.Types.Int, a)] -> v a
  type Mutable :: (* -> *) -> * -> * -> *
  type family Mutable v = mv | mv -> v
  type Vector :: (* -> *) -> * -> Constraint
  class Data.Vector.Generic.Mutable.Base.MVector (Mutable v) a => Vector v a where
    basicUnsafeFreeze :: forall s. Mutable v s a -> GHC.ST.ST s (v a)
    basicUnsafeThaw :: forall s. v a -> GHC.ST.ST s (Mutable v s a)
    basicLength :: v a -> GHC.Types.Int
    basicUnsafeSlice :: GHC.Types.Int -> GHC.Types.Int -> v a -> v a
    basicUnsafeIndexM :: v a -> GHC.Types.Int -> Data.Stream.Monadic.Box a
    basicUnsafeCopy :: forall s. Mutable v s a -> v a -> GHC.ST.ST s ()
    elemseq :: forall b. v a -> a -> b -> b
    {-# MINIMAL basicUnsafeFreeze, basicUnsafeThaw, basicLength, basicUnsafeSlice, basicUnsafeIndexM #-}
    {-# MINIMAL basicUnsafeFreeze, basicUnsafeThaw, basicLength, basicUnsafeSlice, basicUnsafeIndexM #-}
  accum :: forall (v :: * -> *) a b. Vector v a => (a -> b -> a) -> v a -> [(GHC.Types.Int, b)] -> v a
  accumulate :: forall (v :: * -> *) a b. (Vector v a, Vector v (GHC.Types.Int, b)) => (a -> b -> a) -> v a -> v (GHC.Types.Int, b) -> v a
  accumulate_ :: forall (v :: * -> *) a b. (Vector v a, Vector v GHC.Types.Int, Vector v b) => (a -> b -> a) -> v a -> v GHC.Types.Int -> v b -> v a
  all :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> GHC.Types.Bool
  and :: forall (v :: * -> *). Vector v GHC.Types.Bool => v GHC.Types.Bool -> GHC.Types.Bool
  any :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> GHC.Types.Bool
  backpermute :: forall (v :: * -> *) a. (GHC.Stack.Types.HasCallStack, Vector v a, Vector v GHC.Types.Int) => v a -> v GHC.Types.Int -> v a
  break :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> (v a, v a)
  clone :: forall (v :: * -> *) a. Vector v a => v a -> Data.Vector.Generic.New.New v a
  cmp :: forall (v :: * -> *) a. (Vector v a, GHC.Classes.Ord a) => v a -> v a -> GHC.Types.Ordering
  cmpBy :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> GHC.Types.Ordering) -> v a -> v b -> GHC.Types.Ordering
  concat :: forall (v :: * -> *) a. Vector v a => [v a] -> v a
  concatMap :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> v b) -> v a -> v b
  concatNE :: forall (v :: * -> *) a. Vector v a => GHC.Base.NonEmpty (v a) -> v a
  cons :: forall (v :: * -> *) a. Vector v a => a -> v a -> v a
  constructN :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> (v a -> a) -> v a
  constructrN :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> (v a -> a) -> v a
  convert :: forall (v :: * -> *) a (w :: * -> *). (Vector v a, Vector w a) => v a -> w a
  copy :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Stack.Types.HasCallStack, Control.Monad.Primitive.PrimMonad m, Vector v a) => Mutable v (Control.Monad.Primitive.PrimState m) a -> v a -> m ()
  create :: forall (v :: * -> *) a. Vector v a => (forall s. GHC.ST.ST s (Mutable v s a)) -> v a
  createT :: forall (f :: * -> *) (v :: * -> *) a. (Data.Traversable.Traversable f, Vector v a) => (forall s. GHC.ST.ST s (f (Mutable v s a))) -> f (v a)
  dataCast :: forall (v :: * -> *) a (t :: * -> *) (c :: * -> *). (Vector v a, Data.Data.Data a, base-4.18.2.1:Data.Typeable.Internal.Typeable v, base-4.18.2.1:Data.Typeable.Internal.Typeable t) => (forall d. Data.Data.Data d => c (t d)) -> GHC.Maybe.Maybe (c (v a))
  drop :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> v a -> v a
  dropWhile :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> v a
  elem :: forall (v :: * -> *) a. (Vector v a, GHC.Classes.Eq a) => a -> v a -> GHC.Types.Bool
  elemIndex :: forall (v :: * -> *) a. (Vector v a, GHC.Classes.Eq a) => a -> v a -> GHC.Maybe.Maybe GHC.Types.Int
  elemIndices :: forall (v :: * -> *) a. (Vector v a, Vector v GHC.Types.Int, GHC.Classes.Eq a) => a -> v a -> v GHC.Types.Int
  empty :: forall (v :: * -> *) a. Vector v a => v a
  enumFromN :: forall (v :: * -> *) a. (Vector v a, GHC.Num.Num a) => a -> GHC.Types.Int -> v a
  enumFromStepN :: forall (v :: * -> *) a. (Vector v a, GHC.Num.Num a) => a -> a -> GHC.Types.Int -> v a
  enumFromThenTo :: forall (v :: * -> *) a. (Vector v a, GHC.Enum.Enum a) => a -> a -> a -> v a
  enumFromTo :: forall (v :: * -> *) a. (Vector v a, GHC.Enum.Enum a) => a -> a -> v a
  eq :: forall (v :: * -> *) a. (Vector v a, GHC.Classes.Eq a) => v a -> v a -> GHC.Types.Bool
  eqBy :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> GHC.Types.Bool) -> v a -> v b -> GHC.Types.Bool
  filter :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> v a
  filterM :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Vector v a) => (a -> m GHC.Types.Bool) -> v a -> m (v a)
  find :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> GHC.Maybe.Maybe a
  findIndex :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> GHC.Maybe.Maybe GHC.Types.Int
  findIndexR :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> GHC.Maybe.Maybe GHC.Types.Int
  findIndices :: forall (v :: * -> *) a. (Vector v a, Vector v GHC.Types.Int) => (a -> GHC.Types.Bool) -> v a -> v GHC.Types.Int
  fold1M :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Vector v a) => (a -> a -> m a) -> v a -> m a
  fold1M' :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Vector v a) => (a -> a -> m a) -> v a -> m a
  fold1M'_ :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Vector v a) => (a -> a -> m a) -> v a -> m ()
  fold1M_ :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Vector v a) => (a -> a -> m a) -> v a -> m ()
  foldM :: forall (m :: * -> *) (v :: * -> *) b a. (GHC.Base.Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m a
  foldM' :: forall (m :: * -> *) (v :: * -> *) b a. (GHC.Base.Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m a
  foldM'_ :: forall (m :: * -> *) (v :: * -> *) b a. (GHC.Base.Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m ()
  foldM_ :: forall (m :: * -> *) (v :: * -> *) b a. (GHC.Base.Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m ()
  foldMap :: forall m (v :: * -> *) a. (GHC.Base.Monoid m, Vector v a) => (a -> m) -> v a -> m
  foldMap' :: forall m (v :: * -> *) a. (GHC.Base.Monoid m, Vector v a) => (a -> m) -> v a -> m
  foldl :: forall (v :: * -> *) b a. Vector v b => (a -> b -> a) -> a -> v b -> a
  foldl' :: forall (v :: * -> *) b a. Vector v b => (a -> b -> a) -> a -> v b -> a
  foldl1 :: forall (v :: * -> *) a. Vector v a => (a -> a -> a) -> v a -> a
  foldl1' :: forall (v :: * -> *) a. Vector v a => (a -> a -> a) -> v a -> a
  foldr :: forall (v :: * -> *) a b. Vector v a => (a -> b -> b) -> b -> v a -> b
  foldr' :: forall (v :: * -> *) a b. Vector v a => (a -> b -> b) -> b -> v a -> b
  foldr1 :: forall (v :: * -> *) a. Vector v a => (a -> a -> a) -> v a -> a
  foldr1' :: forall (v :: * -> *) a. Vector v a => (a -> a -> a) -> v a -> a
  forM :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a, Vector v b) => v a -> (a -> m b) -> m (v b)
  forM_ :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a) => v a -> (a -> m b) -> m ()
  force :: forall (v :: * -> *) a. Vector v a => v a -> v a
  freeze :: forall (m :: * -> *) (v :: * -> *) a. (Control.Monad.Primitive.PrimMonad m, Vector v a) => Mutable v (Control.Monad.Primitive.PrimState m) a -> m (v a)
  fromList :: forall (v :: * -> *) a. Vector v a => [a] -> v a
  fromListN :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> [a] -> v a
  generate :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> (GHC.Types.Int -> a) -> v a
  generateM :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Vector v a) => GHC.Types.Int -> (GHC.Types.Int -> m a) -> m (v a)
  gfoldl :: forall (v :: * -> *) a (c :: * -> *). (Vector v a, Data.Data.Data a) => (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> v a -> c (v a)
  group :: forall (v :: * -> *) a. (Vector v a, GHC.Classes.Eq a) => v a -> [v a]
  groupBy :: forall (v :: * -> *) a. Vector v a => (a -> a -> GHC.Types.Bool) -> v a -> [v a]
  gunfold :: forall (v :: * -> *) a (c :: * -> *). (Vector v a, Data.Data.Data a, GHC.Stack.Types.HasCallStack) => (forall b r. Data.Data.Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Data.Data.Constr -> c (v a)
  head :: forall (v :: * -> *) a. Vector v a => v a -> a
  headM :: forall (v :: * -> *) a (m :: * -> *). (Vector v a, GHC.Base.Monad m) => v a -> m a
  ifilter :: forall (v :: * -> *) a. Vector v a => (GHC.Types.Int -> a -> GHC.Types.Bool) -> v a -> v a
  ifoldM :: forall (m :: * -> *) (v :: * -> *) b a. (GHC.Base.Monad m, Vector v b) => (a -> GHC.Types.Int -> b -> m a) -> a -> v b -> m a
  ifoldM' :: forall (m :: * -> *) (v :: * -> *) b a. (GHC.Base.Monad m, Vector v b) => (a -> GHC.Types.Int -> b -> m a) -> a -> v b -> m a
  ifoldM'_ :: forall (m :: * -> *) (v :: * -> *) b a. (GHC.Base.Monad m, Vector v b) => (a -> GHC.Types.Int -> b -> m a) -> a -> v b -> m ()
  ifoldM_ :: forall (m :: * -> *) (v :: * -> *) b a. (GHC.Base.Monad m, Vector v b) => (a -> GHC.Types.Int -> b -> m a) -> a -> v b -> m ()
  ifoldl :: forall (v :: * -> *) b a. Vector v b => (a -> GHC.Types.Int -> b -> a) -> a -> v b -> a
  ifoldl' :: forall (v :: * -> *) b a. Vector v b => (a -> GHC.Types.Int -> b -> a) -> a -> v b -> a
  ifoldr :: forall (v :: * -> *) a b. Vector v a => (GHC.Types.Int -> a -> b -> b) -> b -> v a -> b
  ifoldr' :: forall (v :: * -> *) a b. Vector v a => (GHC.Types.Int -> a -> b -> b) -> b -> v a -> b
  iforM :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a, Vector v b) => v a -> (GHC.Types.Int -> a -> m b) -> m (v b)
  iforM_ :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a) => v a -> (GHC.Types.Int -> a -> m b) -> m ()
  imap :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (GHC.Types.Int -> a -> b) -> v a -> v b
  imapM :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a, Vector v b) => (GHC.Types.Int -> a -> m b) -> v a -> m (v b)
  imapM_ :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a) => (GHC.Types.Int -> a -> m b) -> v a -> m ()
  imapMaybe :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (GHC.Types.Int -> a -> GHC.Maybe.Maybe b) -> v a -> v b
  imapMaybeM :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a, Vector v b) => (GHC.Types.Int -> a -> m (GHC.Maybe.Maybe b)) -> v a -> m (v b)
  indexM :: forall (v :: * -> *) a (m :: * -> *). (GHC.Stack.Types.HasCallStack, Vector v a, GHC.Base.Monad m) => v a -> GHC.Types.Int -> m a
  indexed :: forall (v :: * -> *) a. (Vector v a, Vector v (GHC.Types.Int, a)) => v a -> v (GHC.Types.Int, a)
  init :: forall (v :: * -> *) a. Vector v a => v a -> v a
  iscanl :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (GHC.Types.Int -> a -> b -> a) -> a -> v b -> v a
  iscanl' :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (GHC.Types.Int -> a -> b -> a) -> a -> v b -> v a
  iscanr :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (GHC.Types.Int -> a -> b -> b) -> b -> v a -> v b
  iscanr' :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (GHC.Types.Int -> a -> b -> b) -> b -> v a -> v b
  iterateN :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> (a -> a) -> a -> v a
  iterateNM :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Vector v a) => GHC.Types.Int -> (a -> m a) -> a -> m (v a)
  izipWith :: forall (v :: * -> *) a b c. (Vector v a, Vector v b, Vector v c) => (GHC.Types.Int -> a -> b -> c) -> v a -> v b -> v c
  izipWith3 :: forall (v :: * -> *) a b c d. (Vector v a, Vector v b, Vector v c, Vector v d) => (GHC.Types.Int -> a -> b -> c -> d) -> v a -> v b -> v c -> v d
  izipWith4 :: forall (v :: * -> *) a b c d e. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (GHC.Types.Int -> a -> b -> c -> d -> e) -> v a -> v b -> v c -> v d -> v e
  izipWith5 :: forall (v :: * -> *) a b c d e f. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (GHC.Types.Int -> a -> b -> c -> d -> e -> f) -> v a -> v b -> v c -> v d -> v e -> v f
  izipWith6 :: forall (v :: * -> *) a b c d e f g. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (GHC.Types.Int -> a -> b -> c -> d -> e -> f -> g) -> v a -> v b -> v c -> v d -> v e -> v f -> v g
  izipWithM :: forall (m :: * -> *) (v :: * -> *) a b c. (GHC.Base.Monad m, Vector v a, Vector v b, Vector v c) => (GHC.Types.Int -> a -> b -> m c) -> v a -> v b -> m (v c)
  izipWithM_ :: forall (m :: * -> *) (v :: * -> *) a b c. (GHC.Base.Monad m, Vector v a, Vector v b) => (GHC.Types.Int -> a -> b -> m c) -> v a -> v b -> m ()
  last :: forall (v :: * -> *) a. Vector v a => v a -> a
  lastM :: forall (v :: * -> *) a (m :: * -> *). (Vector v a, GHC.Base.Monad m) => v a -> m a
  length :: forall (v :: * -> *) a. Vector v a => v a -> GHC.Types.Int
  liftReadsPrec :: forall (v :: * -> *) a. Vector v a => (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (v a)
  liftShowsPrec :: forall (v :: * -> *) a. Vector v a => (GHC.Types.Int -> a -> GHC.Show.ShowS) -> ([a] -> GHC.Show.ShowS) -> GHC.Types.Int -> v a -> GHC.Show.ShowS
  map :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b) -> v a -> v b
  mapM :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a, Vector v b) => (a -> m b) -> v a -> m (v b)
  mapM_ :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a) => (a -> m b) -> v a -> m ()
  mapMaybe :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> GHC.Maybe.Maybe b) -> v a -> v b
  mapMaybeM :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a, Vector v b) => (a -> m (GHC.Maybe.Maybe b)) -> v a -> m (v b)
  maxIndex :: forall (v :: * -> *) a. (Vector v a, GHC.Classes.Ord a) => v a -> GHC.Types.Int
  maxIndexBy :: forall (v :: * -> *) a. Vector v a => (a -> a -> GHC.Types.Ordering) -> v a -> GHC.Types.Int
  maximum :: forall (v :: * -> *) a. (Vector v a, GHC.Classes.Ord a) => v a -> a
  maximumBy :: forall (v :: * -> *) a. Vector v a => (a -> a -> GHC.Types.Ordering) -> v a -> a
  maximumOn :: forall b (v :: * -> *) a. (GHC.Classes.Ord b, Vector v a) => (a -> b) -> v a -> a
  minIndex :: forall (v :: * -> *) a. (Vector v a, GHC.Classes.Ord a) => v a -> GHC.Types.Int
  minIndexBy :: forall (v :: * -> *) a. Vector v a => (a -> a -> GHC.Types.Ordering) -> v a -> GHC.Types.Int
  minimum :: forall (v :: * -> *) a. (Vector v a, GHC.Classes.Ord a) => v a -> a
  minimumBy :: forall (v :: * -> *) a. Vector v a => (a -> a -> GHC.Types.Ordering) -> v a -> a
  minimumOn :: forall b (v :: * -> *) a. (GHC.Classes.Ord b, Vector v a) => (a -> b) -> v a -> a
  mkType :: GHC.Base.String -> Data.Data.DataType
  mkVecConstr :: GHC.Base.String -> Data.Data.Constr
  mkVecType :: GHC.Base.String -> Data.Data.DataType
  modify :: forall (v :: * -> *) a. Vector v a => (forall s. Mutable v s a -> GHC.ST.ST s ()) -> v a -> v a
  new :: forall (v :: * -> *) a. Vector v a => Data.Vector.Generic.New.New v a -> v a
  notElem :: forall (v :: * -> *) a. (Vector v a, GHC.Classes.Eq a) => a -> v a -> GHC.Types.Bool
  null :: forall (v :: * -> *) a. Vector v a => v a -> GHC.Types.Bool
  or :: forall (v :: * -> *). Vector v GHC.Types.Bool => v GHC.Types.Bool -> GHC.Types.Bool
  partition :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> (v a, v a)
  partitionWith :: forall (v :: * -> *) a b c. (Vector v a, Vector v b, Vector v c) => (a -> Data.Either.Either b c) -> v a -> (v b, v c)
  postscanl :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
  postscanl' :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
  postscanr :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
  postscanr' :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
  prescanl :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
  prescanl' :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
  prescanr :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
  prescanr' :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
  product :: forall (v :: * -> *) a. (Vector v a, GHC.Num.Num a) => v a -> a
  readPrec :: forall (v :: * -> *) a. (Vector v a, GHC.Read.Read a) => Text.ParserCombinators.ReadPrec.ReadPrec (v a)
  replicate :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> a -> v a
  replicateM :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Vector v a) => GHC.Types.Int -> m a -> m (v a)
  reverse :: forall (v :: * -> *) a. Vector v a => v a -> v a
  scanl :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
  scanl' :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
  scanl1 :: forall (v :: * -> *) a. Vector v a => (a -> a -> a) -> v a -> v a
  scanl1' :: forall (v :: * -> *) a. Vector v a => (a -> a -> a) -> v a -> v a
  scanr :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
  scanr' :: forall (v :: * -> *) a b. (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
  scanr1 :: forall (v :: * -> *) a. Vector v a => (a -> a -> a) -> v a -> v a
  scanr1' :: forall (v :: * -> *) a. Vector v a => (a -> a -> a) -> v a -> v a
  sequence :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Vector v a, Vector v (m a)) => v (m a) -> m (v a)
  sequence_ :: forall (m :: * -> *) (v :: * -> *) a. (GHC.Base.Monad m, Vector v (m a)) => v (m a) -> m ()
  showsPrec :: forall (v :: * -> *) a. (Vector v a, GHC.Show.Show a) => GHC.Types.Int -> v a -> GHC.Show.ShowS
  singleton :: forall (v :: * -> *) a. Vector v a => a -> v a
  slice :: forall (v :: * -> *) a. (GHC.Stack.Types.HasCallStack, Vector v a) => GHC.Types.Int -> GHC.Types.Int -> v a -> v a
  snoc :: forall (v :: * -> *) a. Vector v a => v a -> a -> v a
  span :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> (v a, v a)
  splitAt :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> v a -> (v a, v a)
  stream :: forall (v :: * -> *) a. Vector v a => v a -> Data.Vector.Fusion.Bundle.Bundle v a
  streamR :: forall (v :: * -> *) a (u :: * -> *). Vector v a => v a -> Data.Vector.Fusion.Bundle.Bundle u a
  sum :: forall (v :: * -> *) a. (Vector v a, GHC.Num.Num a) => v a -> a
  tail :: forall (v :: * -> *) a. Vector v a => v a -> v a
  take :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> v a -> v a
  takeWhile :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> v a
  thaw :: forall (m :: * -> *) (v :: * -> *) a. (Control.Monad.Primitive.PrimMonad m, Vector v a) => v a -> m (Mutable v (Control.Monad.Primitive.PrimState m) a)
  toList :: forall (v :: * -> *) a. Vector v a => v a -> [a]
  uncons :: forall (v :: * -> *) a. Vector v a => v a -> GHC.Maybe.Maybe (a, v a)
  unfoldr :: forall (v :: * -> *) a b. Vector v a => (b -> GHC.Maybe.Maybe (a, b)) -> b -> v a
  unfoldrExactN :: forall (v :: * -> *) a b. Vector v a => GHC.Types.Int -> (b -> (a, b)) -> b -> v a
  unfoldrExactNM :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a) => GHC.Types.Int -> (b -> m (a, b)) -> b -> m (v a)
  unfoldrM :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a) => (b -> m (GHC.Maybe.Maybe (a, b))) -> b -> m (v a)
  unfoldrN :: forall (v :: * -> *) a b. Vector v a => GHC.Types.Int -> (b -> GHC.Maybe.Maybe (a, b)) -> b -> v a
  unfoldrNM :: forall (m :: * -> *) (v :: * -> *) a b. (GHC.Base.Monad m, Vector v a) => GHC.Types.Int -> (b -> m (GHC.Maybe.Maybe (a, b))) -> b -> m (v a)
  uniq :: forall (v :: * -> *) a. (Vector v a, GHC.Classes.Eq a) => v a -> v a
  unsafeAccum :: forall (v :: * -> *) a b. Vector v a => (a -> b -> a) -> v a -> [(GHC.Types.Int, b)] -> v a
  unsafeAccumulate :: forall (v :: * -> *) a b. (Vector v a, Vector v (GHC.Types.Int, b)) => (a -> b -> a) -> v a -> v (GHC.Types.Int, b) -> v a
  unsafeAccumulate_ :: forall (v :: * -> *) a b. (Vector v a, Vector v GHC.Types.Int, Vector v b) => (a -> b -> a) -> v a -> v GHC.Types.Int -> v b -> v a
  unsafeBackpermute :: forall (v :: * -> *) a. (Vector v a, Vector v GHC.Types.Int) => v a -> v GHC.Types.Int -> v a
  unsafeCopy :: forall (m :: * -> *) (v :: * -> *) a. (Control.Monad.Primitive.PrimMonad m, Vector v a) => Mutable v (Control.Monad.Primitive.PrimState m) a -> v a -> m ()
  unsafeDrop :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> v a -> v a
  unsafeFreeze :: forall (m :: * -> *) (v :: * -> *) a. (Control.Monad.Primitive.PrimMonad m, Vector v a) => Mutable v (Control.Monad.Primitive.PrimState m) a -> m (v a)
  unsafeHead :: forall (v :: * -> *) a. Vector v a => v a -> a
  unsafeHeadM :: forall (v :: * -> *) a (m :: * -> *). (Vector v a, GHC.Base.Monad m) => v a -> m a
  unsafeIndex :: forall (v :: * -> *) a. Vector v a => v a -> GHC.Types.Int -> a
  unsafeIndexM :: forall (v :: * -> *) a (m :: * -> *). (Vector v a, GHC.Base.Monad m) => v a -> GHC.Types.Int -> m a
  unsafeInit :: forall (v :: * -> *) a. Vector v a => v a -> v a
  unsafeLast :: forall (v :: * -> *) a. Vector v a => v a -> a
  unsafeLastM :: forall (v :: * -> *) a (m :: * -> *). (Vector v a, GHC.Base.Monad m) => v a -> m a
  unsafeSlice :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> GHC.Types.Int -> v a -> v a
  unsafeTail :: forall (v :: * -> *) a. Vector v a => v a -> v a
  unsafeTake :: forall (v :: * -> *) a. Vector v a => GHC.Types.Int -> v a -> v a
  unsafeThaw :: forall (m :: * -> *) (v :: * -> *) a. (Control.Monad.Primitive.PrimMonad m, Vector v a) => v a -> m (Mutable v (Control.Monad.Primitive.PrimState m) a)
  unsafeUpd :: forall (v :: * -> *) a. Vector v a => v a -> [(GHC.Types.Int, a)] -> v a
  unsafeUpdate :: forall (v :: * -> *) a. (Vector v a, Vector v (GHC.Types.Int, a)) => v a -> v (GHC.Types.Int, a) -> v a
  unsafeUpdate_ :: forall (v :: * -> *) a. (Vector v a, Vector v GHC.Types.Int) => v a -> v GHC.Types.Int -> v a -> v a
  unsnoc :: forall (v :: * -> *) a. Vector v a => v a -> GHC.Maybe.Maybe (v a, a)
  unstablePartition :: forall (v :: * -> *) a. Vector v a => (a -> GHC.Types.Bool) -> v a -> (v a, v a)
  unstream :: forall (v :: * -> *) a. Vector v a => Data.Vector.Fusion.Bundle.Bundle v a -> v a
  unstreamM :: forall (m :: * -> *) (v :: * -> *) a (u :: * -> *). (GHC.Base.Monad m, Vector v a) => Data.Vector.Fusion.Bundle.MBundle m u a -> m (v a)
  unstreamR :: forall (v :: * -> *) a. Vector v a => Data.Vector.Fusion.Bundle.Bundle v a -> v a
  unzip :: forall (v :: * -> *) a b. (Vector v a, Vector v b, Vector v (a, b)) => v (a, b) -> (v a, v b)
  unzip3 :: forall (v :: * -> *) a b c. (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => v (a, b, c) -> (v a, v b, v c)
  unzip4 :: forall (v :: * -> *) a b c d. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => v (a, b, c, d) -> (v a, v b, v c, v d)
  unzip5 :: forall (v :: * -> *) a b c d e. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => v (a, b, c, d, e) -> (v a, v b, v c, v d, v e)
  unzip6 :: forall (v :: * -> *) a b c d e f. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => v (a, b, c, d, e, f) -> (v a, v b, v c, v d, v e, v f)
  update :: forall (v :: * -> *) a. (Vector v a, Vector v (GHC.Types.Int, a)) => v a -> v (GHC.Types.Int, a) -> v a
  update_ :: forall (v :: * -> *) a. (Vector v a, Vector v GHC.Types.Int) => v a -> v GHC.Types.Int -> v a -> v a
  zip :: forall (v :: * -> *) a b. (Vector v a, Vector v b, Vector v (a, b)) => v a -> v b -> v (a, b)
  zip3 :: forall (v :: * -> *) a b c. (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => v a -> v b -> v c -> v (a, b, c)
  zip4 :: forall (v :: * -> *) a b c d. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => v a -> v b -> v c -> v d -> v (a, b, c, d)
  zip5 :: forall (v :: * -> *) a b c d e. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => v a -> v b -> v c -> v d -> v e -> v (a, b, c, d, e)
  zip6 :: forall (v :: * -> *) a b c d e f. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => v a -> v b -> v c -> v d -> v e -> v f -> v (a, b, c, d, e, f)
  zipWith :: forall (v :: * -> *) a b c. (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> v a -> v b -> v c
  zipWith3 :: forall (v :: * -> *) a b c d. (Vector v a, Vector v b, Vector v c, Vector v d) => (a -> b -> c -> d) -> v a -> v b -> v c -> v d
  zipWith4 :: forall (v :: * -> *) a b c d e. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (a -> b -> c -> d -> e) -> v a -> v b -> v c -> v d -> v e
  zipWith5 :: forall (v :: * -> *) a b c d e f. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (a -> b -> c -> d -> e -> f) -> v a -> v b -> v c -> v d -> v e -> v f
  zipWith6 :: forall (v :: * -> *) a b c d e f g. (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (a -> b -> c -> d -> e -> f -> g) -> v a -> v b -> v c -> v d -> v e -> v f -> v g
  zipWithM :: forall (m :: * -> *) (v :: * -> *) a b c. (GHC.Base.Monad m, Vector v a, Vector v b, Vector v c) => (a -> b -> m c) -> v a -> v b -> m (v c)
  zipWithM_ :: forall (m :: * -> *) (v :: * -> *) a b c. (GHC.Base.Monad m, Vector v a, Vector v b) => (a -> b -> m c) -> v a -> v b -> m ()

module Data.Vector.Generic.Base where

-- ignored


module Data.Vector.Generic.Mutable where
  type MVector :: (* -> * -> *) -> * -> Constraint
  class MVector v a where
    basicLength :: forall s. v s a -> GHC.Types.Int
    basicUnsafeSlice :: forall s. GHC.Types.Int -> GHC.Types.Int -> v s a -> v s a
    basicOverlaps :: forall s. v s a -> v s a -> GHC.Types.Bool
    basicUnsafeNew :: forall s. GHC.Types.Int -> GHC.ST.ST s (v s a)
    basicInitialize :: forall s. v s a -> GHC.ST.ST s ()
    basicUnsafeReplicate :: forall s. GHC.Types.Int -> a -> GHC.ST.ST s (v s a)
    basicUnsafeRead :: forall s. v s a -> GHC.Types.Int -> GHC.ST.ST s a
    basicUnsafeWrite :: forall s. v s a -> GHC.Types.Int -> a -> GHC.ST.ST s ()
    basicClear :: forall s. v s a -> GHC.ST.ST s ()
    basicSet :: forall s. v s a -> a -> GHC.ST.ST s ()
    basicUnsafeCopy :: forall s. v s a -> v s a -> GHC.ST.ST s ()
    basicUnsafeMove :: forall s. v s a -> v s a -> GHC.ST.ST s ()
    basicUnsafeGrow :: forall s. v s a -> GHC.Types.Int -> GHC.ST.ST s (v s a)
    {-# MINIMAL basicLength, basicUnsafeSlice, basicOverlaps, basicUnsafeNew, basicInitialize, basicUnsafeRead, basicUnsafeWrite #-}
    {-# MINIMAL basicLength, basicUnsafeSlice, basicOverlaps, basicUnsafeNew, basicInitialize, basicUnsafeRead, basicUnsafeWrite #-}
  type PrimMonad :: (* -> *) -> Constraint
  class GHC.Base.Monad m => PrimMonad m where
    type PrimState :: (* -> *) -> *
    type family PrimState m
    Control.Monad.Primitive.primitive :: forall a. (GHC.Prim.State# (PrimState m) -> (# GHC.Prim.State# (PrimState m), a #)) -> m a
    {-# MINIMAL primitive #-}
    {-# MINIMAL Control.Monad.Primitive.primitive #-}
  type RealWorld :: *
  data RealWorld
  accum :: forall (m :: * -> *) (v :: * -> * -> *) a b (u :: * -> *). (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => (a -> b -> a) -> v (PrimState m) a -> Data.Vector.Fusion.Bundle.Bundle u (GHC.Types.Int, b) -> m ()
  clear :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> m ()
  clone :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> m (v (PrimState m) a)
  copy :: forall (m :: * -> *) (v :: * -> * -> *) a. (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()
  drop :: forall (v :: * -> * -> *) a s. MVector v a => GHC.Types.Int -> v s a -> v s a
  exchange :: forall (m :: * -> *) (v :: * -> * -> *) a. (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> a -> m a
  fill :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> Data.Stream.Monadic.Stream m a -> m (v (PrimState m) a)
  fillR :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> Data.Stream.Monadic.Stream m a -> m (v (PrimState m) a)
  foldM :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (b -> a -> m b) -> b -> v (PrimState m) a -> m b
  foldM' :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (b -> a -> m b) -> b -> v (PrimState m) a -> m b
  foldl :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (b -> a -> b) -> b -> v (PrimState m) a -> m b
  foldl' :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (b -> a -> b) -> b -> v (PrimState m) a -> m b
  foldr :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (a -> b -> b) -> b -> v (PrimState m) a -> m b
  foldr' :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (a -> b -> b) -> b -> v (PrimState m) a -> m b
  foldrM :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (a -> b -> m b) -> b -> v (PrimState m) a -> m b
  foldrM' :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (a -> b -> m b) -> b -> v (PrimState m) a -> m b
  forM_ :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> m b) -> m ()
  generate :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => GHC.Types.Int -> (GHC.Types.Int -> a) -> m (v (PrimState m) a)
  generateM :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => GHC.Types.Int -> (GHC.Types.Int -> m a) -> m (v (PrimState m) a)
  grow :: forall (m :: * -> *) (v :: * -> * -> *) a. (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> m (v (PrimState m) a)
  growFront :: forall (m :: * -> *) (v :: * -> * -> *) a. (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> m (v (PrimState m) a)
  ifoldM :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (b -> GHC.Types.Int -> a -> m b) -> b -> v (PrimState m) a -> m b
  ifoldM' :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (b -> GHC.Types.Int -> a -> m b) -> b -> v (PrimState m) a -> m b
  ifoldl :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (b -> GHC.Types.Int -> a -> b) -> b -> v (PrimState m) a -> m b
  ifoldl' :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (b -> GHC.Types.Int -> a -> b) -> b -> v (PrimState m) a -> m b
  ifoldr :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (GHC.Types.Int -> a -> b -> b) -> b -> v (PrimState m) a -> m b
  ifoldr' :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (GHC.Types.Int -> a -> b -> b) -> b -> v (PrimState m) a -> m b
  ifoldrM :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (GHC.Types.Int -> a -> b -> m b) -> b -> v (PrimState m) a -> m b
  ifoldrM' :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (GHC.Types.Int -> a -> b -> m b) -> b -> v (PrimState m) a -> m b
  iforM_ :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => v (PrimState m) a -> (GHC.Types.Int -> a -> m b) -> m ()
  imapM_ :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (GHC.Types.Int -> a -> m b) -> v (PrimState m) a -> m ()
  init :: forall (v :: * -> * -> *) a s. MVector v a => v s a -> v s a
  length :: forall (v :: * -> * -> *) a s. MVector v a => v s a -> GHC.Types.Int
  mapM_ :: forall (m :: * -> *) (v :: * -> * -> *) a b. (PrimMonad m, MVector v a) => (a -> m b) -> v (PrimState m) a -> m ()
  modify :: forall (m :: * -> *) (v :: * -> * -> *) a. (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> a) -> GHC.Types.Int -> m ()
  modifyM :: forall (m :: * -> *) (v :: * -> * -> *) a. (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> m a) -> GHC.Types.Int -> m ()
  move :: forall (m :: * -> *) (v :: * -> * -> *) a. (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()
  mstream :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> Data.Stream.Monadic.Stream m a
  mstreamR :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> Data.Stream.Monadic.Stream m a
  munstream :: forall (m :: * -> *) (v :: * -> * -> *) a (u :: * -> *). (PrimMonad m, MVector v a) => Data.Vector.Fusion.Bundle.MBundle m u a -> m (v (PrimState m) a)
  munstreamR :: forall (m :: * -> *) (v :: * -> * -> *) a (u :: * -> *). (PrimMonad m, MVector v a) => Data.Vector.Fusion.Bundle.MBundle m u a -> m (v (PrimState m) a)
  new :: forall (m :: * -> *) (v :: * -> * -> *) a. (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => GHC.Types.Int -> m (v (PrimState m) a)
  nextPermutation :: forall (m :: * -> *) e (v :: * -> * -> *). (PrimMonad m, GHC.Classes.Ord e, MVector v e) => v (PrimState m) e -> m GHC.Types.Bool
  null :: forall (v :: * -> * -> *) a s. MVector v a => v s a -> GHC.Types.Bool
  overlaps :: forall (v :: * -> * -> *) a s. MVector v a => v s a -> v s a -> GHC.Types.Bool
  partitionBundle :: forall (m :: * -> *) (v :: * -> * -> *) a (u :: * -> *). (PrimMonad m, MVector v a) => (a -> GHC.Types.Bool) -> Data.Vector.Fusion.Bundle.Bundle u a -> m (v (PrimState m) a, v (PrimState m) a)
  partitionWithBundle :: forall (m :: * -> *) (v :: * -> * -> *) a b c (u :: * -> *). (PrimMonad m, MVector v a, MVector v b, MVector v c) => (a -> Data.Either.Either b c) -> Data.Vector.Fusion.Bundle.Bundle u a -> m (v (PrimState m) b, v (PrimState m) c)
  read :: forall (m :: * -> *) (v :: * -> * -> *) a. (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> m a
  readMaybe :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> m (GHC.Maybe.Maybe a)
  replicate :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => GHC.Types.Int -> a -> m (v (PrimState m) a)
  replicateM :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => GHC.Types.Int -> m a -> m (v (PrimState m) a)
  reverse :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> m ()
  set :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> a -> m ()
  slice :: forall (v :: * -> * -> *) a s. (GHC.Stack.Types.HasCallStack, MVector v a) => GHC.Types.Int -> GHC.Types.Int -> v s a -> v s a
  splitAt :: forall (v :: * -> * -> *) a s. MVector v a => GHC.Types.Int -> v s a -> (v s a, v s a)
  swap :: forall (m :: * -> *) (v :: * -> * -> *) a. (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> GHC.Types.Int -> m ()
  tail :: forall (v :: * -> * -> *) a s. MVector v a => v s a -> v s a
  take :: forall (v :: * -> * -> *) a s. MVector v a => GHC.Types.Int -> v s a -> v s a
  transform :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => (Data.Stream.Monadic.Stream m a -> Data.Stream.Monadic.Stream m a) -> v (PrimState m) a -> m (v (PrimState m) a)
  transformR :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => (Data.Stream.Monadic.Stream m a -> Data.Stream.Monadic.Stream m a) -> v (PrimState m) a -> m (v (PrimState m) a)
  unsafeAccum :: forall (m :: * -> *) (v :: * -> * -> *) a b (u :: * -> *). (PrimMonad m, MVector v a) => (a -> b -> a) -> v (PrimState m) a -> Data.Vector.Fusion.Bundle.Bundle u (GHC.Types.Int, b) -> m ()
  unsafeCopy :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()
  unsafeDrop :: forall (v :: * -> * -> *) a s. MVector v a => GHC.Types.Int -> v s a -> v s a
  unsafeExchange :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> a -> m a
  unsafeGrow :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> m (v (PrimState m) a)
  unsafeGrowFront :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> m (v (PrimState m) a)
  unsafeInit :: forall (v :: * -> * -> *) a s. MVector v a => v s a -> v s a
  unsafeModify :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> a) -> GHC.Types.Int -> m ()
  unsafeModifyM :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> m a) -> GHC.Types.Int -> m ()
  unsafeMove :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()
  unsafeNew :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => GHC.Types.Int -> m (v (PrimState m) a)
  unsafeRead :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> m a
  unsafeSlice :: forall (v :: * -> * -> *) a s. MVector v a => GHC.Types.Int -> GHC.Types.Int -> v s a -> v s a
  unsafeSwap :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> GHC.Types.Int -> m ()
  unsafeTail :: forall (v :: * -> * -> *) a s. MVector v a => v s a -> v s a
  unsafeTake :: forall (v :: * -> * -> *) a s. MVector v a => GHC.Types.Int -> v s a -> v s a
  unsafeUpdate :: forall (m :: * -> *) (v :: * -> * -> *) a (u :: * -> *). (PrimMonad m, MVector v a) => v (PrimState m) a -> Data.Vector.Fusion.Bundle.Bundle u (GHC.Types.Int, a) -> m ()
  unsafeWrite :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> a -> m ()
  unstablePartition :: forall (m :: * -> *) (v :: * -> * -> *) a. (PrimMonad m, MVector v a) => (a -> GHC.Types.Bool) -> v (PrimState m) a -> m GHC.Types.Int
  unstablePartitionBundle :: forall (m :: * -> *) (v :: * -> * -> *) a (u :: * -> *). (PrimMonad m, MVector v a) => (a -> GHC.Types.Bool) -> Data.Vector.Fusion.Bundle.Bundle u a -> m (v (PrimState m) a, v (PrimState m) a)
  unstream :: forall (m :: * -> *) (v :: * -> * -> *) a (u :: * -> *). (PrimMonad m, MVector v a) => Data.Vector.Fusion.Bundle.Bundle u a -> m (v (PrimState m) a)
  unstreamR :: forall (m :: * -> *) (v :: * -> * -> *) a (u :: * -> *). (PrimMonad m, MVector v a) => Data.Vector.Fusion.Bundle.Bundle u a -> m (v (PrimState m) a)
  update :: forall (m :: * -> *) (v :: * -> * -> *) a (u :: * -> *). (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> Data.Vector.Fusion.Bundle.Bundle u (GHC.Types.Int, a) -> m ()
  vunstream :: forall (m :: * -> *) (v :: * -> *) a. (PrimMonad m, Data.Vector.Generic.Base.Vector v a) => Data.Vector.Fusion.Bundle.Bundle v a -> m (Data.Vector.Generic.Base.Mutable v (PrimState m) a)
  write :: forall (m :: * -> *) (v :: * -> * -> *) a. (GHC.Stack.Types.HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> GHC.Types.Int -> a -> m ()

module Data.Vector.Generic.Mutable.Base where
  type MVector :: (* -> * -> *) -> * -> Constraint
  class MVector v a where
    basicLength :: forall s. v s a -> GHC.Types.Int
    basicUnsafeSlice :: forall s. GHC.Types.Int -> GHC.Types.Int -> v s a -> v s a
    basicOverlaps :: forall s. v s a -> v s a -> GHC.Types.Bool
    basicUnsafeNew :: forall s. GHC.Types.Int -> GHC.ST.ST s (v s a)
    basicInitialize :: forall s. v s a -> GHC.ST.ST s ()
    basicUnsafeReplicate :: forall s. GHC.Types.Int -> a -> GHC.ST.ST s (v s a)
    basicUnsafeRead :: forall s. v s a -> GHC.Types.Int -> GHC.ST.ST s a
    basicUnsafeWrite :: forall s. v s a -> GHC.Types.Int -> a -> GHC.ST.ST s ()
    basicClear :: forall s. v s a -> GHC.ST.ST s ()
    basicSet :: forall s. v s a -> a -> GHC.ST.ST s ()
    basicUnsafeCopy :: forall s. v s a -> v s a -> GHC.ST.ST s ()
    basicUnsafeMove :: forall s. v s a -> v s a -> GHC.ST.ST s ()
    basicUnsafeGrow :: forall s. v s a -> GHC.Types.Int -> GHC.ST.ST s (v s a)
    {-# MINIMAL basicLength, basicUnsafeSlice, basicOverlaps, basicUnsafeNew, basicInitialize, basicUnsafeRead, basicUnsafeWrite #-}
    {-# MINIMAL basicLength, basicUnsafeSlice, basicOverlaps, basicUnsafeNew, basicInitialize, basicUnsafeRead, basicUnsafeWrite #-}

module Data.Vector.Generic.New where
  type role New nominal nominal
  type New :: (* -> *) -> * -> *
  data New v a = New (forall s. GHC.ST.ST s (Data.Vector.Generic.Base.Mutable v s a))
  apply :: forall (v :: * -> *) a. (forall s. Data.Vector.Generic.Base.Mutable v s a -> Data.Vector.Generic.Base.Mutable v s a) -> New v a -> New v a
  create :: forall (v :: * -> *) a. (forall s. GHC.ST.ST s (Data.Vector.Generic.Base.Mutable v s a)) -> New v a
  drop :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => GHC.Types.Int -> New v a -> New v a
  init :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => New v a -> New v a
  modify :: forall (v :: * -> *) a. (forall s. Data.Vector.Generic.Base.Mutable v s a -> GHC.ST.ST s ()) -> New v a -> New v a
  modifyWithBundle :: forall (v :: * -> *) a (u :: * -> *) b. (forall s. Data.Vector.Generic.Base.Mutable v s a -> Data.Vector.Fusion.Bundle.Bundle u b -> GHC.ST.ST s ()) -> New v a -> Data.Vector.Fusion.Bundle.Bundle u b -> New v a
  run :: forall (v :: * -> *) a s. New v a -> GHC.ST.ST s (Data.Vector.Generic.Base.Mutable v s a)
  runPrim :: forall (m :: * -> *) (v :: * -> *) a. Control.Monad.Primitive.PrimMonad m => New v a -> m (Data.Vector.Generic.Base.Mutable v (Control.Monad.Primitive.PrimState m) a)
  slice :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => GHC.Types.Int -> GHC.Types.Int -> New v a -> New v a
  tail :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => New v a -> New v a
  take :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => GHC.Types.Int -> New v a -> New v a
  transform :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => (forall (m :: * -> *). GHC.Base.Monad m => Data.Stream.Monadic.Stream m a -> Data.Stream.Monadic.Stream m a) -> (Data.Vector.Fusion.Bundle.Size.Size -> Data.Vector.Fusion.Bundle.Size.Size) -> New v a -> New v a
  transformR :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => (forall (m :: * -> *). GHC.Base.Monad m => Data.Stream.Monadic.Stream m a -> Data.Stream.Monadic.Stream m a) -> (Data.Vector.Fusion.Bundle.Size.Size -> Data.Vector.Fusion.Bundle.Size.Size) -> New v a -> New v a
  unsafeInit :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => New v a -> New v a
  unsafeSlice :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => GHC.Types.Int -> GHC.Types.Int -> New v a -> New v a
  unsafeTail :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => New v a -> New v a
  unstream :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => Data.Vector.Fusion.Bundle.Bundle v a -> New v a
  unstreamR :: forall (v :: * -> *) a. Data.Vector.Generic.Base.Vector v a => Data.Vector.Fusion.Bundle.Bundle v a -> New v a

module Data.Vector.Internal.Check where

-- ignored


module Data.Vector.Mutable where
  type IOVector :: * -> *
  type IOVector = MVector RealWorld :: * -> *
  type role MVector nominal representational
  type MVector :: * -> * -> *
  data MVector s a = MVector {Data.Vector.Mutable._offset :: {-# UNPACK #-}GHC.Types.Int, Data.Vector.Mutable._size :: {-# UNPACK #-}GHC.Types.Int, Data.Vector.Mutable._array :: {-# UNPACK #-}(Data.Primitive.Array.MutableArray s a)}
  type PrimMonad :: (* -> *) -> Constraint
  class GHC.Base.Monad m => PrimMonad m where
    type PrimState :: (* -> *) -> *
    type family PrimState m
    Control.Monad.Primitive.primitive :: forall a. (GHC.Prim.State# (PrimState m) -> (# GHC.Prim.State# (PrimState m), a #)) -> m a
    {-# MINIMAL primitive #-}
    {-# MINIMAL Control.Monad.Primitive.primitive #-}
  type RealWorld :: *
  data RealWorld
  type STVector :: * -> * -> *
  type STVector s = MVector s :: * -> *
  clear :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> m ()
  clone :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> m (MVector (PrimState m) a)
  copy :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  drop :: forall s a. GHC.Types.Int -> MVector s a -> MVector s a
  exchange :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> GHC.Types.Int -> a -> m a
  foldM :: forall (m :: * -> *) b a. PrimMonad m => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  foldM' :: forall (m :: * -> *) b a. PrimMonad m => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  foldl :: forall (m :: * -> *) b a. PrimMonad m => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b
  foldl' :: forall (m :: * -> *) b a. PrimMonad m => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b
  foldr :: forall (m :: * -> *) a b. PrimMonad m => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  foldr' :: forall (m :: * -> *) a b. PrimMonad m => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  foldrM :: forall (m :: * -> *) a b. PrimMonad m => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  foldrM' :: forall (m :: * -> *) a b. PrimMonad m => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  forM_ :: forall (m :: * -> *) a b. PrimMonad m => MVector (PrimState m) a -> (a -> m b) -> m ()
  fromMutableArray :: forall (m :: * -> *) a. PrimMonad m => Data.Primitive.Array.MutableArray (PrimState m) a -> m (MVector (PrimState m) a)
  generate :: forall (m :: * -> *) a. PrimMonad m => GHC.Types.Int -> (GHC.Types.Int -> a) -> m (MVector (PrimState m) a)
  generateM :: forall (m :: * -> *) a. PrimMonad m => GHC.Types.Int -> (GHC.Types.Int -> m a) -> m (MVector (PrimState m) a)
  grow :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> GHC.Types.Int -> m (MVector (PrimState m) a)
  ifoldM :: forall (m :: * -> *) b a. PrimMonad m => (b -> GHC.Types.Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldM' :: forall (m :: * -> *) b a. PrimMonad m => (b -> GHC.Types.Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldl :: forall (m :: * -> *) b a. PrimMonad m => (b -> GHC.Types.Int -> a -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldl' :: forall (m :: * -> *) b a. PrimMonad m => (b -> GHC.Types.Int -> a -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldr :: forall (m :: * -> *) a b. PrimMonad m => (GHC.Types.Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldr' :: forall (m :: * -> *) a b. PrimMonad m => (GHC.Types.Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldrM :: forall (m :: * -> *) a b. PrimMonad m => (GHC.Types.Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldrM' :: forall (m :: * -> *) a b. PrimMonad m => (GHC.Types.Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  iforM_ :: forall (m :: * -> *) a b. PrimMonad m => MVector (PrimState m) a -> (GHC.Types.Int -> a -> m b) -> m ()
  imapM_ :: forall (m :: * -> *) a b. PrimMonad m => (GHC.Types.Int -> a -> m b) -> MVector (PrimState m) a -> m ()
  init :: forall s a. MVector s a -> MVector s a
  length :: forall s a. MVector s a -> GHC.Types.Int
  mapM_ :: forall (m :: * -> *) a b. PrimMonad m => (a -> m b) -> MVector (PrimState m) a -> m ()
  modify :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> (a -> a) -> GHC.Types.Int -> m ()
  modifyM :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> (a -> m a) -> GHC.Types.Int -> m ()
  move :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  new :: forall (m :: * -> *) a. PrimMonad m => GHC.Types.Int -> m (MVector (PrimState m) a)
  nextPermutation :: forall (m :: * -> *) e. (PrimMonad m, GHC.Classes.Ord e) => MVector (PrimState m) e -> m GHC.Types.Bool
  null :: forall s a. MVector s a -> GHC.Types.Bool
  overlaps :: forall s a. MVector s a -> MVector s a -> GHC.Types.Bool
  read :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> GHC.Types.Int -> m a
  readMaybe :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> GHC.Types.Int -> m (GHC.Maybe.Maybe a)
  replicate :: forall (m :: * -> *) a. PrimMonad m => GHC.Types.Int -> a -> m (MVector (PrimState m) a)
  replicateM :: forall (m :: * -> *) a. PrimMonad m => GHC.Types.Int -> m a -> m (MVector (PrimState m) a)
  set :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> a -> m ()
  slice :: forall s a. GHC.Types.Int -> GHC.Types.Int -> MVector s a -> MVector s a
  splitAt :: forall s a. GHC.Types.Int -> MVector s a -> (MVector s a, MVector s a)
  swap :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> GHC.Types.Int -> GHC.Types.Int -> m ()
  tail :: forall s a. MVector s a -> MVector s a
  take :: forall s a. GHC.Types.Int -> MVector s a -> MVector s a
  toMutableArray :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> m (Data.Primitive.Array.MutableArray (PrimState m) a)
  unsafeCopy :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  unsafeDrop :: forall s a. GHC.Types.Int -> MVector s a -> MVector s a
  unsafeExchange :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> GHC.Types.Int -> a -> m a
  unsafeGrow :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> GHC.Types.Int -> m (MVector (PrimState m) a)
  unsafeInit :: forall s a. MVector s a -> MVector s a
  unsafeModify :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> (a -> a) -> GHC.Types.Int -> m ()
  unsafeModifyM :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> (a -> m a) -> GHC.Types.Int -> m ()
  unsafeMove :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  unsafeNew :: forall (m :: * -> *) a. PrimMonad m => GHC.Types.Int -> m (MVector (PrimState m) a)
  unsafeRead :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> GHC.Types.Int -> m a
  unsafeSlice :: forall s a. GHC.Types.Int -> GHC.Types.Int -> MVector s a -> MVector s a
  unsafeSwap :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> GHC.Types.Int -> GHC.Types.Int -> m ()
  unsafeTail :: forall s a. MVector s a -> MVector s a
  unsafeTake :: forall s a. GHC.Types.Int -> MVector s a -> MVector s a
  unsafeWrite :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> GHC.Types.Int -> a -> m ()
  write :: forall (m :: * -> *) a. PrimMonad m => MVector (PrimState m) a -> GHC.Types.Int -> a -> m ()

module Data.Vector.Primitive where
  (!) :: forall a. Prim a => Vector a -> GHC.Types.Int -> a
  (!?) :: forall a. Prim a => Vector a -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: forall a. Prim a => Vector a -> Vector a -> Vector a
  (//) :: forall a. Prim a => Vector a -> [(GHC.Types.Int, a)] -> Vector a
  type role MVector nominal nominal
  type MVector :: * -> * -> *
  data MVector s a = MVector {-# UNPACK #-}GHC.Types.Int {-# UNPACK #-}GHC.Types.Int {-# UNPACK #-}(Data.Array.Byte.MutableByteArray s)
  type Prim :: * -> Constraint
  class Prim a where
    Data.Primitive.Types.sizeOfType# :: Data.Proxy.Proxy a -> GHC.Prim.Int#
    Data.Primitive.Types.sizeOf# :: a -> GHC.Prim.Int#
    Data.Primitive.Types.alignmentOfType# :: Data.Proxy.Proxy a -> GHC.Prim.Int#
    Data.Primitive.Types.alignment# :: a -> GHC.Prim.Int#
    Data.Primitive.Types.indexByteArray# :: GHC.Prim.ByteArray# -> GHC.Prim.Int# -> a
    Data.Primitive.Types.readByteArray# :: forall s. GHC.Prim.MutableByteArray# s -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, a #)
    Data.Primitive.Types.writeByteArray# :: forall s. GHC.Prim.MutableByteArray# s -> GHC.Prim.Int# -> a -> GHC.Prim.State# s -> GHC.Prim.State# s
    Data.Primitive.Types.setByteArray# :: forall s. GHC.Prim.MutableByteArray# s -> GHC.Prim.Int# -> GHC.Prim.Int# -> a -> GHC.Prim.State# s -> GHC.Prim.State# s
    Data.Primitive.Types.indexOffAddr# :: GHC.Prim.Addr# -> GHC.Prim.Int# -> a
    Data.Primitive.Types.readOffAddr# :: forall s. GHC.Prim.Addr# -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, a #)
    Data.Primitive.Types.writeOffAddr# :: forall s. GHC.Prim.Addr# -> GHC.Prim.Int# -> a -> GHC.Prim.State# s -> GHC.Prim.State# s
    Data.Primitive.Types.setOffAddr# :: forall s. GHC.Prim.Addr# -> GHC.Prim.Int# -> GHC.Prim.Int# -> a -> GHC.Prim.State# s -> GHC.Prim.State# s
    {-# MINIMAL (sizeOfType# | sizeOf#), (alignmentOfType# | alignment#), indexByteArray#, readByteArray#, writeByteArray#, indexOffAddr#, readOffAddr#, writeOffAddr# #-}
    {-# MINIMAL (Data.Primitive.Types.sizeOfType# | Data.Primitive.Types.sizeOf#), (Data.Primitive.Types.alignmentOfType# | Data.Primitive.Types.alignment#), Data.Primitive.Types.indexByteArray#, Data.Primitive.Types.readByteArray#, Data.Primitive.Types.writeByteArray#, Data.Primitive.Types.indexOffAddr#, Data.Primitive.Types.readOffAddr#, Data.Primitive.Types.writeOffAddr# #-}
  type role Vector nominal
  type Vector :: * -> *
  data Vector a = Vector {-# UNPACK #-}GHC.Types.Int {-# UNPACK #-}GHC.Types.Int {-# UNPACK #-}Data.Array.Byte.ByteArray
  accum :: forall a b. Prim a => (a -> b -> a) -> Vector a -> [(GHC.Types.Int, b)] -> Vector a
  accumulate_ :: forall a b. (Prim a, Prim b) => (a -> b -> a) -> Vector a -> Vector GHC.Types.Int -> Vector b -> Vector a
  all :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Types.Bool
  any :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Types.Bool
  backpermute :: forall a. Prim a => Vector a -> Vector GHC.Types.Int -> Vector a
  break :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  cmpBy :: forall a b. (Prim a, Prim b) => (a -> b -> GHC.Types.Ordering) -> Vector a -> Vector b -> GHC.Types.Ordering
  concat :: forall a. Prim a => [Vector a] -> Vector a
  concatMap :: forall a b. (Prim a, Prim b) => (a -> Vector b) -> Vector a -> Vector b
  cons :: forall a. Prim a => a -> Vector a -> Vector a
  constructN :: forall a. Prim a => GHC.Types.Int -> (Vector a -> a) -> Vector a
  constructrN :: forall a. Prim a => GHC.Types.Int -> (Vector a -> a) -> Vector a
  convert :: forall (v :: * -> *) a (w :: * -> *). (Data.Vector.Generic.Base.Vector v a, Data.Vector.Generic.Base.Vector w a) => v a -> w a
  copy :: forall a (m :: * -> *). (Prim a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> Vector a -> m ()
  create :: forall a. Prim a => (forall s. GHC.ST.ST s (MVector s a)) -> Vector a
  createT :: forall (f :: * -> *) a. (Data.Traversable.Traversable f, Prim a) => (forall s. GHC.ST.ST s (f (MVector s a))) -> f (Vector a)
  drop :: forall a. Prim a => GHC.Types.Int -> Vector a -> Vector a
  dropWhile :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> Vector a
  elem :: forall a. (Prim a, GHC.Classes.Eq a) => a -> Vector a -> GHC.Types.Bool
  elemIndex :: forall a. (Prim a, GHC.Classes.Eq a) => a -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  elemIndices :: forall a. (Prim a, GHC.Classes.Eq a) => a -> Vector a -> Vector GHC.Types.Int
  empty :: forall a. Prim a => Vector a
  enumFromN :: forall a. (Prim a, GHC.Num.Num a) => a -> GHC.Types.Int -> Vector a
  enumFromStepN :: forall a. (Prim a, GHC.Num.Num a) => a -> a -> GHC.Types.Int -> Vector a
  enumFromThenTo :: forall a. (Prim a, GHC.Enum.Enum a) => a -> a -> a -> Vector a
  enumFromTo :: forall a. (Prim a, GHC.Enum.Enum a) => a -> a -> Vector a
  eqBy :: forall a b. (Prim a, Prim b) => (a -> b -> GHC.Types.Bool) -> Vector a -> Vector b -> GHC.Types.Bool
  filter :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> Vector a
  filterM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Prim a) => (a -> m GHC.Types.Bool) -> Vector a -> m (Vector a)
  find :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe a
  findIndex :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  findIndexR :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  findIndices :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> Vector GHC.Types.Int
  fold1M :: forall (m :: * -> *) a. (GHC.Base.Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m a
  fold1M' :: forall (m :: * -> *) a. (GHC.Base.Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m a
  fold1M'_ :: forall (m :: * -> *) a. (GHC.Base.Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m ()
  fold1M_ :: forall (m :: * -> *) a. (GHC.Base.Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m ()
  foldM :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m a
  foldM' :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m a
  foldM'_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m ()
  foldM_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m ()
  foldMap :: forall m a. (GHC.Base.Monoid m, Prim a) => (a -> m) -> Vector a -> m
  foldMap' :: forall m a. (GHC.Base.Monoid m, Prim a) => (a -> m) -> Vector a -> m
  foldl :: forall b a. Prim b => (a -> b -> a) -> a -> Vector b -> a
  foldl' :: forall b a. Prim b => (a -> b -> a) -> a -> Vector b -> a
  foldl1 :: forall a. Prim a => (a -> a -> a) -> Vector a -> a
  foldl1' :: forall a. Prim a => (a -> a -> a) -> Vector a -> a
  foldr :: forall a b. Prim a => (a -> b -> b) -> b -> Vector a -> b
  foldr' :: forall a b. Prim a => (a -> b -> b) -> b -> Vector a -> b
  foldr1 :: forall a. Prim a => (a -> a -> a) -> Vector a -> a
  foldr1' :: forall a. Prim a => (a -> a -> a) -> Vector a -> a
  forM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a, Prim b) => Vector a -> (a -> m b) -> m (Vector b)
  forM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a) => Vector a -> (a -> m b) -> m ()
  force :: forall a. Prim a => Vector a -> Vector a
  freeze :: forall a (m :: * -> *). (Prim a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> m (Vector a)
  fromList :: forall a. Prim a => [a] -> Vector a
  fromListN :: forall a. Prim a => GHC.Types.Int -> [a] -> Vector a
  generate :: forall a. Prim a => GHC.Types.Int -> (GHC.Types.Int -> a) -> Vector a
  generateM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Prim a) => GHC.Types.Int -> (GHC.Types.Int -> m a) -> m (Vector a)
  group :: forall a. (Prim a, GHC.Classes.Eq a) => Vector a -> [Vector a]
  groupBy :: forall a. Prim a => (a -> a -> GHC.Types.Bool) -> Vector a -> [Vector a]
  head :: forall a. Prim a => Vector a -> a
  headM :: forall a (m :: * -> *). (Prim a, GHC.Base.Monad m) => Vector a -> m a
  ifilter :: forall a. Prim a => (GHC.Types.Int -> a -> GHC.Types.Bool) -> Vector a -> Vector a
  ifoldM :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Prim b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m a
  ifoldM' :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Prim b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m a
  ifoldM'_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Prim b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m ()
  ifoldM_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Prim b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m ()
  ifoldl :: forall b a. Prim b => (a -> GHC.Types.Int -> b -> a) -> a -> Vector b -> a
  ifoldl' :: forall b a. Prim b => (a -> GHC.Types.Int -> b -> a) -> a -> Vector b -> a
  ifoldr :: forall a b. Prim a => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> b
  ifoldr' :: forall a b. Prim a => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> b
  iforM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a, Prim b) => Vector a -> (GHC.Types.Int -> a -> m b) -> m (Vector b)
  iforM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a) => Vector a -> (GHC.Types.Int -> a -> m b) -> m ()
  imap :: forall a b. (Prim a, Prim b) => (GHC.Types.Int -> a -> b) -> Vector a -> Vector b
  imapM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a, Prim b) => (GHC.Types.Int -> a -> m b) -> Vector a -> m (Vector b)
  imapM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a) => (GHC.Types.Int -> a -> m b) -> Vector a -> m ()
  imapMaybe :: forall a b. (Prim a, Prim b) => (GHC.Types.Int -> a -> GHC.Maybe.Maybe b) -> Vector a -> Vector b
  imapMaybeM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a, Prim b) => (GHC.Types.Int -> a -> m (GHC.Maybe.Maybe b)) -> Vector a -> m (Vector b)
  indexM :: forall a (m :: * -> *). (Prim a, GHC.Base.Monad m) => Vector a -> GHC.Types.Int -> m a
  init :: forall a. Prim a => Vector a -> Vector a
  iscanl :: forall a b. (Prim a, Prim b) => (GHC.Types.Int -> a -> b -> a) -> a -> Vector b -> Vector a
  iscanl' :: forall a b. (Prim a, Prim b) => (GHC.Types.Int -> a -> b -> a) -> a -> Vector b -> Vector a
  iscanr :: forall a b. (Prim a, Prim b) => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> Vector b
  iscanr' :: forall a b. (Prim a, Prim b) => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> Vector b
  iterateN :: forall a. Prim a => GHC.Types.Int -> (a -> a) -> a -> Vector a
  iterateNM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Prim a) => GHC.Types.Int -> (a -> m a) -> a -> m (Vector a)
  izipWith :: forall a b c. (Prim a, Prim b, Prim c) => (GHC.Types.Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c
  izipWith3 :: forall a b c d. (Prim a, Prim b, Prim c, Prim d) => (GHC.Types.Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
  izipWith4 :: forall a b c d e. (Prim a, Prim b, Prim c, Prim d, Prim e) => (GHC.Types.Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
  izipWith5 :: forall a b c d e f. (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f) => (GHC.Types.Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
  izipWith6 :: forall a b c d e f g. (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f, Prim g) => (GHC.Types.Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
  izipWithM :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Prim a, Prim b, Prim c) => (GHC.Types.Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
  izipWithM_ :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Prim a, Prim b) => (GHC.Types.Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()
  last :: forall a. Prim a => Vector a -> a
  lastM :: forall a (m :: * -> *). (Prim a, GHC.Base.Monad m) => Vector a -> m a
  length :: forall a. Prim a => Vector a -> GHC.Types.Int
  map :: forall a b. (Prim a, Prim b) => (a -> b) -> Vector a -> Vector b
  mapM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a, Prim b) => (a -> m b) -> Vector a -> m (Vector b)
  mapM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a) => (a -> m b) -> Vector a -> m ()
  mapMaybe :: forall a b. (Prim a, Prim b) => (a -> GHC.Maybe.Maybe b) -> Vector a -> Vector b
  mapMaybeM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a, Prim b) => (a -> m (GHC.Maybe.Maybe b)) -> Vector a -> m (Vector b)
  maxIndex :: forall a. (Prim a, GHC.Classes.Ord a) => Vector a -> GHC.Types.Int
  maxIndexBy :: forall a. Prim a => (a -> a -> GHC.Types.Ordering) -> Vector a -> GHC.Types.Int
  maximum :: forall a. (Prim a, GHC.Classes.Ord a) => Vector a -> a
  maximumBy :: forall a. Prim a => (a -> a -> GHC.Types.Ordering) -> Vector a -> a
  maximumOn :: forall b a. (GHC.Classes.Ord b, Prim a) => (a -> b) -> Vector a -> a
  minIndex :: forall a. (Prim a, GHC.Classes.Ord a) => Vector a -> GHC.Types.Int
  minIndexBy :: forall a. Prim a => (a -> a -> GHC.Types.Ordering) -> Vector a -> GHC.Types.Int
  minimum :: forall a. (Prim a, GHC.Classes.Ord a) => Vector a -> a
  minimumBy :: forall a. Prim a => (a -> a -> GHC.Types.Ordering) -> Vector a -> a
  minimumOn :: forall b a. (GHC.Classes.Ord b, Prim a) => (a -> b) -> Vector a -> a
  modify :: forall a. Prim a => (forall s. MVector s a -> GHC.ST.ST s ()) -> Vector a -> Vector a
  notElem :: forall a. (Prim a, GHC.Classes.Eq a) => a -> Vector a -> GHC.Types.Bool
  null :: forall a. Prim a => Vector a -> GHC.Types.Bool
  partition :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  partitionWith :: forall a b c. (Prim a, Prim b, Prim c) => (a -> Data.Either.Either b c) -> Vector a -> (Vector b, Vector c)
  postscanl :: forall a b. (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a
  postscanl' :: forall a b. (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a
  postscanr :: forall a b. (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b
  postscanr' :: forall a b. (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b
  prescanl :: forall a b. (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a
  prescanl' :: forall a b. (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a
  prescanr :: forall a b. (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b
  prescanr' :: forall a b. (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b
  product :: forall a. (Prim a, GHC.Num.Num a) => Vector a -> a
  replicate :: forall a. Prim a => GHC.Types.Int -> a -> Vector a
  replicateM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Prim a) => GHC.Types.Int -> m a -> m (Vector a)
  reverse :: forall a. Prim a => Vector a -> Vector a
  scanl :: forall a b. (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a
  scanl' :: forall a b. (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a
  scanl1 :: forall a. Prim a => (a -> a -> a) -> Vector a -> Vector a
  scanl1' :: forall a. Prim a => (a -> a -> a) -> Vector a -> Vector a
  scanr :: forall a b. (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b
  scanr' :: forall a b. (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b
  scanr1 :: forall a. Prim a => (a -> a -> a) -> Vector a -> Vector a
  scanr1' :: forall a. Prim a => (a -> a -> a) -> Vector a -> Vector a
  singleton :: forall a. Prim a => a -> Vector a
  slice :: forall a. Prim a => GHC.Types.Int -> GHC.Types.Int -> Vector a -> Vector a
  snoc :: forall a. Prim a => Vector a -> a -> Vector a
  span :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  splitAt :: forall a. Prim a => GHC.Types.Int -> Vector a -> (Vector a, Vector a)
  sum :: forall a. (Prim a, GHC.Num.Num a) => Vector a -> a
  tail :: forall a. Prim a => Vector a -> Vector a
  take :: forall a. Prim a => GHC.Types.Int -> Vector a -> Vector a
  takeWhile :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> Vector a
  thaw :: forall a (m :: * -> *). (Prim a, Control.Monad.Primitive.PrimMonad m) => Vector a -> m (MVector (Control.Monad.Primitive.PrimState m) a)
  toList :: forall a. Prim a => Vector a -> [a]
  uncons :: forall a. Prim a => Vector a -> GHC.Maybe.Maybe (a, Vector a)
  unfoldr :: forall a b. Prim a => (b -> GHC.Maybe.Maybe (a, b)) -> b -> Vector a
  unfoldrExactN :: forall a b. Prim a => GHC.Types.Int -> (b -> (a, b)) -> b -> Vector a
  unfoldrExactNM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a) => GHC.Types.Int -> (b -> m (a, b)) -> b -> m (Vector a)
  unfoldrM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a) => (b -> m (GHC.Maybe.Maybe (a, b))) -> b -> m (Vector a)
  unfoldrN :: forall a b. Prim a => GHC.Types.Int -> (b -> GHC.Maybe.Maybe (a, b)) -> b -> Vector a
  unfoldrNM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Prim a) => GHC.Types.Int -> (b -> m (GHC.Maybe.Maybe (a, b))) -> b -> m (Vector a)
  uniq :: forall a. (Prim a, GHC.Classes.Eq a) => Vector a -> Vector a
  unsafeAccum :: forall a b. Prim a => (a -> b -> a) -> Vector a -> [(GHC.Types.Int, b)] -> Vector a
  unsafeAccumulate_ :: forall a b. (Prim a, Prim b) => (a -> b -> a) -> Vector a -> Vector GHC.Types.Int -> Vector b -> Vector a
  unsafeBackpermute :: forall a. Prim a => Vector a -> Vector GHC.Types.Int -> Vector a
  unsafeCast :: forall a b. (GHC.Stack.Types.HasCallStack, Prim a, Prim b) => Vector a -> Vector b
  unsafeCoerceVector :: forall a b. Coercible a b => Vector a -> Vector b
  unsafeCopy :: forall a (m :: * -> *). (Prim a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> Vector a -> m ()
  unsafeDrop :: forall a. Prim a => GHC.Types.Int -> Vector a -> Vector a
  unsafeFreeze :: forall a (m :: * -> *). (Prim a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> m (Vector a)
  unsafeHead :: forall a. Prim a => Vector a -> a
  unsafeHeadM :: forall a (m :: * -> *). (Prim a, GHC.Base.Monad m) => Vector a -> m a
  unsafeIndex :: forall a. Prim a => Vector a -> GHC.Types.Int -> a
  unsafeIndexM :: forall a (m :: * -> *). (Prim a, GHC.Base.Monad m) => Vector a -> GHC.Types.Int -> m a
  unsafeInit :: forall a. Prim a => Vector a -> Vector a
  unsafeLast :: forall a. Prim a => Vector a -> a
  unsafeLastM :: forall a (m :: * -> *). (Prim a, GHC.Base.Monad m) => Vector a -> m a
  unsafeSlice :: forall a. Prim a => GHC.Types.Int -> GHC.Types.Int -> Vector a -> Vector a
  unsafeTail :: forall a. Prim a => Vector a -> Vector a
  unsafeTake :: forall a. Prim a => GHC.Types.Int -> Vector a -> Vector a
  unsafeThaw :: forall a (m :: * -> *). (Prim a, Control.Monad.Primitive.PrimMonad m) => Vector a -> m (MVector (Control.Monad.Primitive.PrimState m) a)
  unsafeUpd :: forall a. Prim a => Vector a -> [(GHC.Types.Int, a)] -> Vector a
  unsafeUpdate_ :: forall a. Prim a => Vector a -> Vector GHC.Types.Int -> Vector a -> Vector a
  unsnoc :: forall a. Prim a => Vector a -> GHC.Maybe.Maybe (Vector a, a)
  unstablePartition :: forall a. Prim a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  update_ :: forall a. Prim a => Vector a -> Vector GHC.Types.Int -> Vector a -> Vector a
  zipWith :: forall a b c. (Prim a, Prim b, Prim c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c
  zipWith3 :: forall a b c d. (Prim a, Prim b, Prim c, Prim d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
  zipWith4 :: forall a b c d e. (Prim a, Prim b, Prim c, Prim d, Prim e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
  zipWith5 :: forall a b c d e f. (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
  zipWith6 :: forall a b c d e f g. (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f, Prim g) => (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
  zipWithM :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Prim a, Prim b, Prim c) => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
  zipWithM_ :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Prim a, Prim b) => (a -> b -> m c) -> Vector a -> Vector b -> m ()

module Data.Vector.Primitive.Mutable where
  type IOVector :: * -> *
  type IOVector = MVector RealWorld :: * -> *
  type role MVector nominal nominal
  type MVector :: * -> * -> *
  data MVector s a = MVector {-# UNPACK #-}GHC.Types.Int {-# UNPACK #-}GHC.Types.Int {-# UNPACK #-}(Data.Array.Byte.MutableByteArray s)
  type Prim :: * -> Constraint
  class Prim a where
    Data.Primitive.Types.sizeOfType# :: Data.Proxy.Proxy a -> GHC.Prim.Int#
    Data.Primitive.Types.sizeOf# :: a -> GHC.Prim.Int#
    Data.Primitive.Types.alignmentOfType# :: Data.Proxy.Proxy a -> GHC.Prim.Int#
    Data.Primitive.Types.alignment# :: a -> GHC.Prim.Int#
    Data.Primitive.Types.indexByteArray# :: GHC.Prim.ByteArray# -> GHC.Prim.Int# -> a
    Data.Primitive.Types.readByteArray# :: forall s. GHC.Prim.MutableByteArray# s -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, a #)
    Data.Primitive.Types.writeByteArray# :: forall s. GHC.Prim.MutableByteArray# s -> GHC.Prim.Int# -> a -> GHC.Prim.State# s -> GHC.Prim.State# s
    Data.Primitive.Types.setByteArray# :: forall s. GHC.Prim.MutableByteArray# s -> GHC.Prim.Int# -> GHC.Prim.Int# -> a -> GHC.Prim.State# s -> GHC.Prim.State# s
    Data.Primitive.Types.indexOffAddr# :: GHC.Prim.Addr# -> GHC.Prim.Int# -> a
    Data.Primitive.Types.readOffAddr# :: forall s. GHC.Prim.Addr# -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, a #)
    Data.Primitive.Types.writeOffAddr# :: forall s. GHC.Prim.Addr# -> GHC.Prim.Int# -> a -> GHC.Prim.State# s -> GHC.Prim.State# s
    Data.Primitive.Types.setOffAddr# :: forall s. GHC.Prim.Addr# -> GHC.Prim.Int# -> GHC.Prim.Int# -> a -> GHC.Prim.State# s -> GHC.Prim.State# s
    {-# MINIMAL (sizeOfType# | sizeOf#), (alignmentOfType# | alignment#), indexByteArray#, readByteArray#, writeByteArray#, indexOffAddr#, readOffAddr#, writeOffAddr# #-}
    {-# MINIMAL (Data.Primitive.Types.sizeOfType# | Data.Primitive.Types.sizeOf#), (Data.Primitive.Types.alignmentOfType# | Data.Primitive.Types.alignment#), Data.Primitive.Types.indexByteArray#, Data.Primitive.Types.readByteArray#, Data.Primitive.Types.writeByteArray#, Data.Primitive.Types.indexOffAddr#, Data.Primitive.Types.readOffAddr#, Data.Primitive.Types.writeOffAddr# #-}
  type PrimMonad :: (* -> *) -> Constraint
  class GHC.Base.Monad m => PrimMonad m where
    type PrimState :: (* -> *) -> *
    type family PrimState m
    Control.Monad.Primitive.primitive :: forall a. (GHC.Prim.State# (PrimState m) -> (# GHC.Prim.State# (PrimState m), a #)) -> m a
    {-# MINIMAL primitive #-}
    {-# MINIMAL Control.Monad.Primitive.primitive #-}
  type RealWorld :: *
  data RealWorld
  type STVector :: * -> * -> *
  type STVector s = MVector s :: * -> *
  clear :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> m ()
  clone :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> m (MVector (PrimState m) a)
  copy :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  drop :: forall a s. Prim a => GHC.Types.Int -> MVector s a -> MVector s a
  exchange :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m a
  foldM :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  foldM' :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  foldl :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b
  foldl' :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b
  foldr :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  foldr' :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  foldrM :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  foldrM' :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  forM_ :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> m b) -> m ()
  generate :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => GHC.Types.Int -> (GHC.Types.Int -> a) -> m (MVector (PrimState m) a)
  generateM :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => GHC.Types.Int -> (GHC.Types.Int -> m a) -> m (MVector (PrimState m) a)
  grow :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> GHC.Types.Int -> m (MVector (PrimState m) a)
  ifoldM :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (b -> GHC.Types.Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldM' :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (b -> GHC.Types.Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldl :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (b -> GHC.Types.Int -> a -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldl' :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (b -> GHC.Types.Int -> a -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldr :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (GHC.Types.Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldr' :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (GHC.Types.Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldrM :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (GHC.Types.Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldrM' :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (GHC.Types.Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  iforM_ :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => MVector (PrimState m) a -> (GHC.Types.Int -> a -> m b) -> m ()
  imapM_ :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (GHC.Types.Int -> a -> m b) -> MVector (PrimState m) a -> m ()
  init :: forall a s. Prim a => MVector s a -> MVector s a
  length :: forall a s. Prim a => MVector s a -> GHC.Types.Int
  mapM_ :: forall (m :: * -> *) a b. (PrimMonad m, Prim a) => (a -> m b) -> MVector (PrimState m) a -> m ()
  modify :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> a) -> GHC.Types.Int -> m ()
  modifyM :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> m a) -> GHC.Types.Int -> m ()
  move :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  new :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => GHC.Types.Int -> m (MVector (PrimState m) a)
  nextPermutation :: forall (m :: * -> *) e. (PrimMonad m, GHC.Classes.Ord e, Prim e) => MVector (PrimState m) e -> m GHC.Types.Bool
  null :: forall a s. Prim a => MVector s a -> GHC.Types.Bool
  overlaps :: forall a s. Prim a => MVector s a -> MVector s a -> GHC.Types.Bool
  read :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> GHC.Types.Int -> m a
  readMaybe :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> GHC.Types.Int -> m (GHC.Maybe.Maybe a)
  replicate :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => GHC.Types.Int -> a -> m (MVector (PrimState m) a)
  replicateM :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => GHC.Types.Int -> m a -> m (MVector (PrimState m) a)
  set :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> a -> m ()
  slice :: forall a s. Prim a => GHC.Types.Int -> GHC.Types.Int -> MVector s a -> MVector s a
  splitAt :: forall a s. Prim a => GHC.Types.Int -> MVector s a -> (MVector s a, MVector s a)
  swap :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> GHC.Types.Int -> GHC.Types.Int -> m ()
  tail :: forall a s. Prim a => MVector s a -> MVector s a
  take :: forall a s. Prim a => GHC.Types.Int -> MVector s a -> MVector s a
  unsafeCast :: forall a b s. (GHC.Stack.Types.HasCallStack, Prim a, Prim b) => MVector s a -> MVector s b
  unsafeCoerceMVector :: forall a b s. Coercible a b => MVector s a -> MVector s b
  unsafeCopy :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  unsafeDrop :: forall a s. Prim a => GHC.Types.Int -> MVector s a -> MVector s a
  unsafeExchange :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m a
  unsafeGrow :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> GHC.Types.Int -> m (MVector (PrimState m) a)
  unsafeInit :: forall a s. Prim a => MVector s a -> MVector s a
  unsafeModify :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> a) -> GHC.Types.Int -> m ()
  unsafeModifyM :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> m a) -> GHC.Types.Int -> m ()
  unsafeMove :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  unsafeNew :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => GHC.Types.Int -> m (MVector (PrimState m) a)
  unsafeRead :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> GHC.Types.Int -> m a
  unsafeSlice :: forall a s. Prim a => GHC.Types.Int -> GHC.Types.Int -> MVector s a -> MVector s a
  unsafeSwap :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> GHC.Types.Int -> GHC.Types.Int -> m ()
  unsafeTail :: forall a s. Prim a => MVector s a -> MVector s a
  unsafeTake :: forall a s. Prim a => GHC.Types.Int -> MVector s a -> MVector s a
  unsafeWrite :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m ()
  write :: forall (m :: * -> *) a. (PrimMonad m, Prim a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m ()

module Data.Vector.Storable where
  (!) :: forall a. Storable a => Vector a -> GHC.Types.Int -> a
  (!?) :: forall a. Storable a => Vector a -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: forall a. Storable a => Vector a -> Vector a -> Vector a
  (//) :: forall a. Storable a => Vector a -> [(GHC.Types.Int, a)] -> Vector a
  type role MVector nominal nominal
  type MVector :: * -> * -> *
  data MVector s a = MVector {-# UNPACK #-}GHC.Types.Int {-# UNPACK #-}(GHC.ForeignPtr.ForeignPtr a)
  type Storable :: * -> Constraint
  class Storable a where
    Foreign.Storable.sizeOf :: a -> GHC.Types.Int
    Foreign.Storable.alignment :: a -> GHC.Types.Int
    Foreign.Storable.peekElemOff :: GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
    Foreign.Storable.pokeElemOff :: GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
    Foreign.Storable.peekByteOff :: forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
    Foreign.Storable.pokeByteOff :: forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
    Foreign.Storable.peek :: GHC.Ptr.Ptr a -> GHC.Types.IO a
    Foreign.Storable.poke :: GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
    {-# MINIMAL sizeOf, alignment, (peek | peekElemOff | peekByteOff), (poke | pokeElemOff | pokeByteOff) #-}
    {-# MINIMAL Foreign.Storable.sizeOf, Foreign.Storable.alignment, (Foreign.Storable.peek | Foreign.Storable.peekElemOff | Foreign.Storable.peekByteOff), (Foreign.Storable.poke | Foreign.Storable.pokeElemOff | Foreign.Storable.pokeByteOff) #-}
  type role Vector nominal
  type Vector :: * -> *
  data Vector a = Data.Vector.Storable.Vector {-# UNPACK #-}GHC.Types.Int {-# UNPACK #-}(GHC.ForeignPtr.ForeignPtr a)
  accum :: forall a b. Storable a => (a -> b -> a) -> Vector a -> [(GHC.Types.Int, b)] -> Vector a
  accumulate_ :: forall a b. (Storable a, Storable b) => (a -> b -> a) -> Vector a -> Vector GHC.Types.Int -> Vector b -> Vector a
  all :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Types.Bool
  and :: Vector GHC.Types.Bool -> GHC.Types.Bool
  any :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Types.Bool
  backpermute :: forall a. Storable a => Vector a -> Vector GHC.Types.Int -> Vector a
  break :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  cmpBy :: forall a b. (Storable a, Storable b) => (a -> b -> GHC.Types.Ordering) -> Vector a -> Vector b -> GHC.Types.Ordering
  concat :: forall a. Storable a => [Vector a] -> Vector a
  concatMap :: forall a b. (Storable a, Storable b) => (a -> Vector b) -> Vector a -> Vector b
  cons :: forall a. Storable a => a -> Vector a -> Vector a
  constructN :: forall a. Storable a => GHC.Types.Int -> (Vector a -> a) -> Vector a
  constructrN :: forall a. Storable a => GHC.Types.Int -> (Vector a -> a) -> Vector a
  convert :: forall (v :: * -> *) a (w :: * -> *). (Data.Vector.Generic.Base.Vector v a, Data.Vector.Generic.Base.Vector w a) => v a -> w a
  copy :: forall a (m :: * -> *). (Storable a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> Vector a -> m ()
  create :: forall a. Storable a => (forall s. GHC.ST.ST s (MVector s a)) -> Vector a
  createT :: forall (f :: * -> *) a. (Data.Traversable.Traversable f, Storable a) => (forall s. GHC.ST.ST s (f (MVector s a))) -> f (Vector a)
  drop :: forall a. Storable a => GHC.Types.Int -> Vector a -> Vector a
  dropWhile :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> Vector a
  elem :: forall a. (Storable a, GHC.Classes.Eq a) => a -> Vector a -> GHC.Types.Bool
  elemIndex :: forall a. (Storable a, GHC.Classes.Eq a) => a -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  elemIndices :: forall a. (Storable a, GHC.Classes.Eq a) => a -> Vector a -> Vector GHC.Types.Int
  empty :: forall a. Storable a => Vector a
  enumFromN :: forall a. (Storable a, GHC.Num.Num a) => a -> GHC.Types.Int -> Vector a
  enumFromStepN :: forall a. (Storable a, GHC.Num.Num a) => a -> a -> GHC.Types.Int -> Vector a
  enumFromThenTo :: forall a. (Storable a, GHC.Enum.Enum a) => a -> a -> a -> Vector a
  enumFromTo :: forall a. (Storable a, GHC.Enum.Enum a) => a -> a -> Vector a
  eqBy :: forall a b. (Storable a, Storable b) => (a -> b -> GHC.Types.Bool) -> Vector a -> Vector b -> GHC.Types.Bool
  filter :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> Vector a
  filterM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Storable a) => (a -> m GHC.Types.Bool) -> Vector a -> m (Vector a)
  find :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe a
  findIndex :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  findIndexR :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  findIndices :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> Vector GHC.Types.Int
  fold1M :: forall (m :: * -> *) a. (GHC.Base.Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m a
  fold1M' :: forall (m :: * -> *) a. (GHC.Base.Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m a
  fold1M'_ :: forall (m :: * -> *) a. (GHC.Base.Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m ()
  fold1M_ :: forall (m :: * -> *) a. (GHC.Base.Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m ()
  foldM :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m a
  foldM' :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m a
  foldM'_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m ()
  foldM_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m ()
  foldMap :: forall m a. (GHC.Base.Monoid m, Storable a) => (a -> m) -> Vector a -> m
  foldMap' :: forall m a. (GHC.Base.Monoid m, Storable a) => (a -> m) -> Vector a -> m
  foldl :: forall b a. Storable b => (a -> b -> a) -> a -> Vector b -> a
  foldl' :: forall b a. Storable b => (a -> b -> a) -> a -> Vector b -> a
  foldl1 :: forall a. Storable a => (a -> a -> a) -> Vector a -> a
  foldl1' :: forall a. Storable a => (a -> a -> a) -> Vector a -> a
  foldr :: forall a b. Storable a => (a -> b -> b) -> b -> Vector a -> b
  foldr' :: forall a b. Storable a => (a -> b -> b) -> b -> Vector a -> b
  foldr1 :: forall a. Storable a => (a -> a -> a) -> Vector a -> a
  foldr1' :: forall a. Storable a => (a -> a -> a) -> Vector a -> a
  forM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a, Storable b) => Vector a -> (a -> m b) -> m (Vector b)
  forM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a) => Vector a -> (a -> m b) -> m ()
  force :: forall a. Storable a => Vector a -> Vector a
  freeze :: forall a (m :: * -> *). (Storable a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> m (Vector a)
  fromList :: forall a. Storable a => [a] -> Vector a
  fromListN :: forall a. Storable a => GHC.Types.Int -> [a] -> Vector a
  generate :: forall a. Storable a => GHC.Types.Int -> (GHC.Types.Int -> a) -> Vector a
  generateM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Storable a) => GHC.Types.Int -> (GHC.Types.Int -> m a) -> m (Vector a)
  group :: forall a. (Storable a, GHC.Classes.Eq a) => Vector a -> [Vector a]
  groupBy :: forall a. Storable a => (a -> a -> GHC.Types.Bool) -> Vector a -> [Vector a]
  head :: forall a. Storable a => Vector a -> a
  headM :: forall a (m :: * -> *). (Storable a, GHC.Base.Monad m) => Vector a -> m a
  ifilter :: forall a. Storable a => (GHC.Types.Int -> a -> GHC.Types.Bool) -> Vector a -> Vector a
  ifoldM :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Storable b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m a
  ifoldM' :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Storable b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m a
  ifoldM'_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Storable b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m ()
  ifoldM_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Storable b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m ()
  ifoldl :: forall b a. Storable b => (a -> GHC.Types.Int -> b -> a) -> a -> Vector b -> a
  ifoldl' :: forall b a. Storable b => (a -> GHC.Types.Int -> b -> a) -> a -> Vector b -> a
  ifoldr :: forall a b. Storable a => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> b
  ifoldr' :: forall a b. Storable a => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> b
  iforM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a, Storable b) => Vector a -> (GHC.Types.Int -> a -> m b) -> m (Vector b)
  iforM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a) => Vector a -> (GHC.Types.Int -> a -> m b) -> m ()
  imap :: forall a b. (Storable a, Storable b) => (GHC.Types.Int -> a -> b) -> Vector a -> Vector b
  imapM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a, Storable b) => (GHC.Types.Int -> a -> m b) -> Vector a -> m (Vector b)
  imapM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a) => (GHC.Types.Int -> a -> m b) -> Vector a -> m ()
  imapMaybe :: forall a b. (Storable a, Storable b) => (GHC.Types.Int -> a -> GHC.Maybe.Maybe b) -> Vector a -> Vector b
  imapMaybeM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a, Storable b) => (GHC.Types.Int -> a -> m (GHC.Maybe.Maybe b)) -> Vector a -> m (Vector b)
  indexM :: forall a (m :: * -> *). (Storable a, GHC.Base.Monad m) => Vector a -> GHC.Types.Int -> m a
  init :: forall a. Storable a => Vector a -> Vector a
  isSameVector :: forall a. Storable a => Vector a -> Vector a -> GHC.Types.Bool
  iscanl :: forall a b. (Storable a, Storable b) => (GHC.Types.Int -> a -> b -> a) -> a -> Vector b -> Vector a
  iscanl' :: forall a b. (Storable a, Storable b) => (GHC.Types.Int -> a -> b -> a) -> a -> Vector b -> Vector a
  iscanr :: forall a b. (Storable a, Storable b) => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> Vector b
  iscanr' :: forall a b. (Storable a, Storable b) => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> Vector b
  iterateN :: forall a. Storable a => GHC.Types.Int -> (a -> a) -> a -> Vector a
  iterateNM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Storable a) => GHC.Types.Int -> (a -> m a) -> a -> m (Vector a)
  izipWith :: forall a b c. (Storable a, Storable b, Storable c) => (GHC.Types.Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c
  izipWith3 :: forall a b c d. (Storable a, Storable b, Storable c, Storable d) => (GHC.Types.Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
  izipWith4 :: forall a b c d e. (Storable a, Storable b, Storable c, Storable d, Storable e) => (GHC.Types.Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
  izipWith5 :: forall a b c d e f. (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (GHC.Types.Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
  izipWith6 :: forall a b c d e f g. (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (GHC.Types.Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
  izipWithM :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Storable a, Storable b, Storable c) => (GHC.Types.Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
  izipWithM_ :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Storable a, Storable b) => (GHC.Types.Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()
  last :: forall a. Storable a => Vector a -> a
  lastM :: forall a (m :: * -> *). (Storable a, GHC.Base.Monad m) => Vector a -> m a
  length :: forall a. Storable a => Vector a -> GHC.Types.Int
  map :: forall a b. (Storable a, Storable b) => (a -> b) -> Vector a -> Vector b
  mapM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a, Storable b) => (a -> m b) -> Vector a -> m (Vector b)
  mapM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a) => (a -> m b) -> Vector a -> m ()
  mapMaybe :: forall a b. (Storable a, Storable b) => (a -> GHC.Maybe.Maybe b) -> Vector a -> Vector b
  mapMaybeM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a, Storable b) => (a -> m (GHC.Maybe.Maybe b)) -> Vector a -> m (Vector b)
  maxIndex :: forall a. (Storable a, GHC.Classes.Ord a) => Vector a -> GHC.Types.Int
  maxIndexBy :: forall a. Storable a => (a -> a -> GHC.Types.Ordering) -> Vector a -> GHC.Types.Int
  maximum :: forall a. (Storable a, GHC.Classes.Ord a) => Vector a -> a
  maximumBy :: forall a. Storable a => (a -> a -> GHC.Types.Ordering) -> Vector a -> a
  maximumOn :: forall b a. (GHC.Classes.Ord b, Storable a) => (a -> b) -> Vector a -> a
  minIndex :: forall a. (Storable a, GHC.Classes.Ord a) => Vector a -> GHC.Types.Int
  minIndexBy :: forall a. Storable a => (a -> a -> GHC.Types.Ordering) -> Vector a -> GHC.Types.Int
  minimum :: forall a. (Storable a, GHC.Classes.Ord a) => Vector a -> a
  minimumBy :: forall a. Storable a => (a -> a -> GHC.Types.Ordering) -> Vector a -> a
  minimumOn :: forall b a. (GHC.Classes.Ord b, Storable a) => (a -> b) -> Vector a -> a
  modify :: forall a. Storable a => (forall s. MVector s a -> GHC.ST.ST s ()) -> Vector a -> Vector a
  notElem :: forall a. (Storable a, GHC.Classes.Eq a) => a -> Vector a -> GHC.Types.Bool
  null :: forall a. Storable a => Vector a -> GHC.Types.Bool
  or :: Vector GHC.Types.Bool -> GHC.Types.Bool
  partition :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  partitionWith :: forall a b c. (Storable a, Storable b, Storable c) => (a -> Data.Either.Either b c) -> Vector a -> (Vector b, Vector c)
  postscanl :: forall a b. (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
  postscanl' :: forall a b. (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
  postscanr :: forall a b. (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
  postscanr' :: forall a b. (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
  prescanl :: forall a b. (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
  prescanl' :: forall a b. (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
  prescanr :: forall a b. (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
  prescanr' :: forall a b. (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
  product :: forall a. (Storable a, GHC.Num.Num a) => Vector a -> a
  replicate :: forall a. Storable a => GHC.Types.Int -> a -> Vector a
  replicateM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Storable a) => GHC.Types.Int -> m a -> m (Vector a)
  reverse :: forall a. Storable a => Vector a -> Vector a
  scanl :: forall a b. (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
  scanl' :: forall a b. (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
  scanl1 :: forall a. Storable a => (a -> a -> a) -> Vector a -> Vector a
  scanl1' :: forall a. Storable a => (a -> a -> a) -> Vector a -> Vector a
  scanr :: forall a b. (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
  scanr' :: forall a b. (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
  scanr1 :: forall a. Storable a => (a -> a -> a) -> Vector a -> Vector a
  scanr1' :: forall a. Storable a => (a -> a -> a) -> Vector a -> Vector a
  singleton :: forall a. Storable a => a -> Vector a
  slice :: forall a. Storable a => GHC.Types.Int -> GHC.Types.Int -> Vector a -> Vector a
  snoc :: forall a. Storable a => Vector a -> a -> Vector a
  span :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  splitAt :: forall a. Storable a => GHC.Types.Int -> Vector a -> (Vector a, Vector a)
  sum :: forall a. (Storable a, GHC.Num.Num a) => Vector a -> a
  tail :: forall a. Storable a => Vector a -> Vector a
  take :: forall a. Storable a => GHC.Types.Int -> Vector a -> Vector a
  takeWhile :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> Vector a
  thaw :: forall a (m :: * -> *). (Storable a, Control.Monad.Primitive.PrimMonad m) => Vector a -> m (MVector (Control.Monad.Primitive.PrimState m) a)
  toList :: forall a. Storable a => Vector a -> [a]
  uncons :: forall a. Storable a => Vector a -> GHC.Maybe.Maybe (a, Vector a)
  unfoldr :: forall a b. Storable a => (b -> GHC.Maybe.Maybe (a, b)) -> b -> Vector a
  unfoldrExactN :: forall a b. Storable a => GHC.Types.Int -> (b -> (a, b)) -> b -> Vector a
  unfoldrExactNM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a) => GHC.Types.Int -> (b -> m (a, b)) -> b -> m (Vector a)
  unfoldrM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a) => (b -> m (GHC.Maybe.Maybe (a, b))) -> b -> m (Vector a)
  unfoldrN :: forall a b. Storable a => GHC.Types.Int -> (b -> GHC.Maybe.Maybe (a, b)) -> b -> Vector a
  unfoldrNM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Storable a) => GHC.Types.Int -> (b -> m (GHC.Maybe.Maybe (a, b))) -> b -> m (Vector a)
  uniq :: forall a. (Storable a, GHC.Classes.Eq a) => Vector a -> Vector a
  unsafeAccum :: forall a b. Storable a => (a -> b -> a) -> Vector a -> [(GHC.Types.Int, b)] -> Vector a
  unsafeAccumulate_ :: forall a b. (Storable a, Storable b) => (a -> b -> a) -> Vector a -> Vector GHC.Types.Int -> Vector b -> Vector a
  unsafeBackpermute :: forall a. Storable a => Vector a -> Vector GHC.Types.Int -> Vector a
  unsafeCast :: forall a b. (Storable a, Storable b) => Vector a -> Vector b
  unsafeCoerceVector :: forall a b. Coercible a b => Vector a -> Vector b
  unsafeCopy :: forall a (m :: * -> *). (Storable a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> Vector a -> m ()
  unsafeDrop :: forall a. Storable a => GHC.Types.Int -> Vector a -> Vector a
  unsafeFreeze :: forall a (m :: * -> *). (Storable a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> m (Vector a)
  unsafeFromForeignPtr :: forall a. Storable a => GHC.ForeignPtr.ForeignPtr a -> GHC.Types.Int -> GHC.Types.Int -> Vector a
  unsafeFromForeignPtr0 :: forall a. GHC.ForeignPtr.ForeignPtr a -> GHC.Types.Int -> Vector a
  unsafeHead :: forall a. Storable a => Vector a -> a
  unsafeHeadM :: forall a (m :: * -> *). (Storable a, GHC.Base.Monad m) => Vector a -> m a
  unsafeIndex :: forall a. Storable a => Vector a -> GHC.Types.Int -> a
  unsafeIndexM :: forall a (m :: * -> *). (Storable a, GHC.Base.Monad m) => Vector a -> GHC.Types.Int -> m a
  unsafeInit :: forall a. Storable a => Vector a -> Vector a
  unsafeLast :: forall a. Storable a => Vector a -> a
  unsafeLastM :: forall a (m :: * -> *). (Storable a, GHC.Base.Monad m) => Vector a -> m a
  unsafeSlice :: forall a. Storable a => GHC.Types.Int -> GHC.Types.Int -> Vector a -> Vector a
  unsafeTail :: forall a. Storable a => Vector a -> Vector a
  unsafeTake :: forall a. Storable a => GHC.Types.Int -> Vector a -> Vector a
  unsafeThaw :: forall a (m :: * -> *). (Storable a, Control.Monad.Primitive.PrimMonad m) => Vector a -> m (MVector (Control.Monad.Primitive.PrimState m) a)
  unsafeToForeignPtr :: forall a. Vector a -> (GHC.ForeignPtr.ForeignPtr a, GHC.Types.Int, GHC.Types.Int)
  unsafeToForeignPtr0 :: forall a. Vector a -> (GHC.ForeignPtr.ForeignPtr a, GHC.Types.Int)
  unsafeUpd :: forall a. Storable a => Vector a -> [(GHC.Types.Int, a)] -> Vector a
  unsafeUpdate_ :: forall a. Storable a => Vector a -> Vector GHC.Types.Int -> Vector a -> Vector a
  unsafeWith :: forall a b. Storable a => Vector a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  unsnoc :: forall a. Storable a => Vector a -> GHC.Maybe.Maybe (Vector a, a)
  unstablePartition :: forall a. Storable a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  update_ :: forall a. Storable a => Vector a -> Vector GHC.Types.Int -> Vector a -> Vector a
  zipWith :: forall a b c. (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c
  zipWith3 :: forall a b c d. (Storable a, Storable b, Storable c, Storable d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
  zipWith4 :: forall a b c d e. (Storable a, Storable b, Storable c, Storable d, Storable e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
  zipWith5 :: forall a b c d e f. (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
  zipWith6 :: forall a b c d e f g. (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
  zipWithM :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Storable a, Storable b, Storable c) => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
  zipWithM_ :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Storable a, Storable b) => (a -> b -> m c) -> Vector a -> Vector b -> m ()

module Data.Vector.Storable.Internal where
  getPtr :: forall a. GHC.ForeignPtr.ForeignPtr a -> GHC.Ptr.Ptr a
  setPtr :: forall a. GHC.ForeignPtr.ForeignPtr a -> GHC.Ptr.Ptr a -> GHC.ForeignPtr.ForeignPtr a
  unsafeWithForeignPtr :: forall a b. GHC.ForeignPtr.ForeignPtr a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  updPtr :: forall a. (GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a) -> GHC.ForeignPtr.ForeignPtr a -> GHC.ForeignPtr.ForeignPtr a

module Data.Vector.Storable.Mutable where
  type IOVector :: * -> *
  type IOVector = MVector RealWorld :: * -> *
  type role MVector nominal nominal
  type MVector :: * -> * -> *
  data MVector s a = MVector {-# UNPACK #-}GHC.Types.Int {-# UNPACK #-}(GHC.ForeignPtr.ForeignPtr a)
  type PrimMonad :: (* -> *) -> Constraint
  class GHC.Base.Monad m => PrimMonad m where
    type PrimState :: (* -> *) -> *
    type family PrimState m
    Control.Monad.Primitive.primitive :: forall a. (GHC.Prim.State# (PrimState m) -> (# GHC.Prim.State# (PrimState m), a #)) -> m a
    {-# MINIMAL primitive #-}
    {-# MINIMAL Control.Monad.Primitive.primitive #-}
  type RealWorld :: *
  data RealWorld
  type STVector :: * -> * -> *
  type STVector s = MVector s :: * -> *
  type Storable :: * -> Constraint
  class Storable a where
    Foreign.Storable.sizeOf :: a -> GHC.Types.Int
    Foreign.Storable.alignment :: a -> GHC.Types.Int
    Foreign.Storable.peekElemOff :: GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
    Foreign.Storable.pokeElemOff :: GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
    Foreign.Storable.peekByteOff :: forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
    Foreign.Storable.pokeByteOff :: forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
    Foreign.Storable.peek :: GHC.Ptr.Ptr a -> GHC.Types.IO a
    Foreign.Storable.poke :: GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
    {-# MINIMAL sizeOf, alignment, (peek | peekElemOff | peekByteOff), (poke | pokeElemOff | pokeByteOff) #-}
    {-# MINIMAL Foreign.Storable.sizeOf, Foreign.Storable.alignment, (Foreign.Storable.peek | Foreign.Storable.peekElemOff | Foreign.Storable.peekByteOff), (Foreign.Storable.poke | Foreign.Storable.pokeElemOff | Foreign.Storable.pokeByteOff) #-}
  clear :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> m ()
  clone :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> m (MVector (PrimState m) a)
  copy :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  drop :: forall a s. Storable a => GHC.Types.Int -> MVector s a -> MVector s a
  exchange :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m a
  foldM :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  foldM' :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  foldl :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b
  foldl' :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b
  foldr :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  foldr' :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  foldrM :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  foldrM' :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  forM_ :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> m b) -> m ()
  generate :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => GHC.Types.Int -> (GHC.Types.Int -> a) -> m (MVector (PrimState m) a)
  generateM :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => GHC.Types.Int -> (GHC.Types.Int -> m a) -> m (MVector (PrimState m) a)
  grow :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> GHC.Types.Int -> m (MVector (PrimState m) a)
  ifoldM :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (b -> GHC.Types.Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldM' :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (b -> GHC.Types.Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldl :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (b -> GHC.Types.Int -> a -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldl' :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (b -> GHC.Types.Int -> a -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldr :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (GHC.Types.Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldr' :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (GHC.Types.Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldrM :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (GHC.Types.Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldrM' :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (GHC.Types.Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  iforM_ :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => MVector (PrimState m) a -> (GHC.Types.Int -> a -> m b) -> m ()
  imapM_ :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (GHC.Types.Int -> a -> m b) -> MVector (PrimState m) a -> m ()
  init :: forall a s. Storable a => MVector s a -> MVector s a
  length :: forall a s. Storable a => MVector s a -> GHC.Types.Int
  mapM_ :: forall (m :: * -> *) a b. (PrimMonad m, Storable a) => (a -> m b) -> MVector (PrimState m) a -> m ()
  modify :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> a) -> GHC.Types.Int -> m ()
  modifyM :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> m a) -> GHC.Types.Int -> m ()
  move :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  new :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => GHC.Types.Int -> m (MVector (PrimState m) a)
  nextPermutation :: forall (m :: * -> *) e. (PrimMonad m, Storable e, GHC.Classes.Ord e) => MVector (PrimState m) e -> m GHC.Types.Bool
  null :: forall a s. Storable a => MVector s a -> GHC.Types.Bool
  overlaps :: forall a s. Storable a => MVector s a -> MVector s a -> GHC.Types.Bool
  read :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> GHC.Types.Int -> m a
  readMaybe :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> GHC.Types.Int -> m (GHC.Maybe.Maybe a)
  replicate :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => GHC.Types.Int -> a -> m (MVector (PrimState m) a)
  replicateM :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => GHC.Types.Int -> m a -> m (MVector (PrimState m) a)
  set :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> a -> m ()
  slice :: forall a s. Storable a => GHC.Types.Int -> GHC.Types.Int -> MVector s a -> MVector s a
  splitAt :: forall a s. Storable a => GHC.Types.Int -> MVector s a -> (MVector s a, MVector s a)
  swap :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> GHC.Types.Int -> GHC.Types.Int -> m ()
  tail :: forall a s. Storable a => MVector s a -> MVector s a
  take :: forall a s. Storable a => GHC.Types.Int -> MVector s a -> MVector s a
  unsafeCast :: forall a b s. (Storable a, Storable b) => MVector s a -> MVector s b
  unsafeCoerceMVector :: forall a b s. Coercible a b => MVector s a -> MVector s b
  unsafeCopy :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  unsafeDrop :: forall a s. Storable a => GHC.Types.Int -> MVector s a -> MVector s a
  unsafeExchange :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m a
  unsafeFromForeignPtr :: forall a s. Storable a => GHC.ForeignPtr.ForeignPtr a -> GHC.Types.Int -> GHC.Types.Int -> MVector s a
  unsafeFromForeignPtr0 :: forall a s. GHC.ForeignPtr.ForeignPtr a -> GHC.Types.Int -> MVector s a
  unsafeGrow :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> GHC.Types.Int -> m (MVector (PrimState m) a)
  unsafeInit :: forall a s. Storable a => MVector s a -> MVector s a
  unsafeModify :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> a) -> GHC.Types.Int -> m ()
  unsafeModifyM :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> m a) -> GHC.Types.Int -> m ()
  unsafeMove :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  unsafeNew :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => GHC.Types.Int -> m (MVector (PrimState m) a)
  unsafeRead :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> GHC.Types.Int -> m a
  unsafeSlice :: forall a s. Storable a => GHC.Types.Int -> GHC.Types.Int -> MVector s a -> MVector s a
  unsafeSwap :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> GHC.Types.Int -> GHC.Types.Int -> m ()
  unsafeTail :: forall a s. Storable a => MVector s a -> MVector s a
  unsafeTake :: forall a s. Storable a => GHC.Types.Int -> MVector s a -> MVector s a
  unsafeToForeignPtr :: forall s a. MVector s a -> (GHC.ForeignPtr.ForeignPtr a, GHC.Types.Int, GHC.Types.Int)
  unsafeToForeignPtr0 :: forall s a. MVector s a -> (GHC.ForeignPtr.ForeignPtr a, GHC.Types.Int)
  unsafeWith :: forall a b. Storable a => IOVector a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  unsafeWrite :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m ()
  write :: forall (m :: * -> *) a. (PrimMonad m, Storable a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m ()

module Data.Vector.Unboxed where
  (!) :: forall a. Unbox a => Vector a -> GHC.Types.Int -> a
  (!?) :: forall a. Unbox a => Vector a -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: forall a. Unbox a => Vector a -> Vector a -> Vector a
  (//) :: forall a. Unbox a => Vector a -> [(GHC.Types.Int, a)] -> Vector a
  type role As representational phantom
  type As :: * -> * -> *
  newtype As a b = As a
  type IsoUnbox :: * -> * -> Constraint
  class IsoUnbox a b where
    toURepr :: a -> b
    default toURepr :: (GHC.Generics.Generic a, GHC.Generics.Generic b, Coercible (GHC.Generics.Rep a ()) (GHC.Generics.Rep b ())) => a -> b
    fromURepr :: b -> a
    default fromURepr :: (GHC.Generics.Generic a, GHC.Generics.Generic b, Coercible (GHC.Generics.Rep b ()) (GHC.Generics.Rep a ())) => b -> a
    {-# MINIMAL #-}
  MV_2 :: forall s a b. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s (a, b)
  MV_3 :: forall s a b c. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s (a, b, c)
  MV_4 :: forall s a b c d. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s (a, b, c, d)
  MV_5 :: forall s a b c d e. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s (a, b, c, d, e)
  MV_6 :: forall s a b c d e f. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s f -> MVector s (a, b, c, d, e, f)
  MV_All :: forall s. MVector s GHC.Types.Bool -> MVector s base-4.18.2.1:Data.Semigroup.Internal.All
  MV_Alt :: forall k s (f :: k -> *) (a :: k). MVector s (f a) -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Alt f a)
  MV_Any :: forall s. MVector s GHC.Types.Bool -> MVector s base-4.18.2.1:Data.Semigroup.Internal.Any
  MV_Arg :: forall s a b. MVector s (a, b) -> MVector s (Data.Semigroup.Arg a b)
  MV_Bool :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8 -> MVector s GHC.Types.Bool
  MV_Char :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Char -> MVector s GHC.Types.Char
  MV_Complex :: forall s a. MVector s (a, a) -> MVector s (Data.Complex.Complex a)
  MV_Compose :: forall k k1 s (f :: k -> *) (g :: k1 -> k) (a :: k1). MVector s (f (g a)) -> MVector s (Data.Functor.Compose.Compose f g a)
  MV_Const :: forall k s a (b :: k). MVector s a -> MVector s (Data.Functor.Const.Const a b)
  MV_Double :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Double -> MVector s GHC.Types.Double
  MV_Down :: forall s a. MVector s a -> MVector s (Data.Ord.Down a)
  MV_Dual :: forall s a. MVector s a -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Dual a)
  MV_First :: forall s a. MVector s a -> MVector s (Data.Semigroup.First a)
  MV_Float :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Float -> MVector s GHC.Types.Float
  MV_Identity :: forall s a. MVector s a -> MVector s (Data.Functor.Identity.Identity a)
  MV_Int :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int -> MVector s GHC.Types.Int
  MV_Int16 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int16 -> MVector s GHC.Int.Int16
  MV_Int32 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int32 -> MVector s GHC.Int.Int32
  MV_Int64 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int64 -> MVector s GHC.Int.Int64
  MV_Int8 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int8 -> MVector s GHC.Int.Int8
  MV_Last :: forall s a. MVector s a -> MVector s (Data.Semigroup.Last a)
  MV_Max :: forall s a. MVector s a -> MVector s (Data.Semigroup.Max a)
  MV_Min :: forall s a. MVector s a -> MVector s (Data.Semigroup.Min a)
  MV_Product :: forall s a. MVector s a -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Product a)
  MV_Sum :: forall s a. MVector s a -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Sum a)
  MV_UnboxAs :: forall s a b. MVector s b -> MVector s (As a b)
  MV_UnboxViaPrim :: forall s a. Data.Vector.Primitive.Mutable.MVector s a -> MVector s (UnboxViaPrim a)
  MV_Unit :: forall s. GHC.Types.Int -> MVector s ()
  MV_Word :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Word -> MVector s GHC.Types.Word
  MV_Word16 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word16 -> MVector s GHC.Word.Word16
  MV_Word32 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word32 -> MVector s GHC.Word.Word32
  MV_Word64 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word64 -> MVector s GHC.Word.Word64
  MV_Word8 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8 -> MVector s GHC.Word.Word8
  MV_WrappedMonoid :: forall s a. MVector s a -> MVector s (Data.Semigroup.WrappedMonoid a)
  type MVector :: * -> * -> *
  data family MVector s a
  type Unbox :: * -> Constraint
  class (Data.Vector.Generic.Base.Vector Vector a, Data.Vector.Generic.Mutable.Base.MVector MVector a) => Unbox a
    {-# MINIMAL #-}
  type UnboxViaPrim :: * -> *
  newtype UnboxViaPrim a = UnboxViaPrim a
  V_UnboxAs :: forall a b. Vector b -> Vector (As a b)
  V_UnboxViaPrim :: forall a. Data.Vector.Primitive.Vector a -> Vector (UnboxViaPrim a)
  type Vector :: * -> *
  data family Vector a
  accum :: forall a b. Unbox a => (a -> b -> a) -> Vector a -> [(GHC.Types.Int, b)] -> Vector a
  accumulate :: forall a b. (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector (GHC.Types.Int, b) -> Vector a
  accumulate_ :: forall a b. (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector GHC.Types.Int -> Vector b -> Vector a
  all :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Types.Bool
  and :: Vector GHC.Types.Bool -> GHC.Types.Bool
  any :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Types.Bool
  backpermute :: forall a. Unbox a => Vector a -> Vector GHC.Types.Int -> Vector a
  break :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  cmpBy :: forall a b. (Unbox a, Unbox b) => (a -> b -> GHC.Types.Ordering) -> Vector a -> Vector b -> GHC.Types.Ordering
  concat :: forall a. Unbox a => [Vector a] -> Vector a
  concatMap :: forall a b. (Unbox a, Unbox b) => (a -> Vector b) -> Vector a -> Vector b
  cons :: forall a. Unbox a => a -> Vector a -> Vector a
  constructN :: forall a. Unbox a => GHC.Types.Int -> (Vector a -> a) -> Vector a
  constructrN :: forall a. Unbox a => GHC.Types.Int -> (Vector a -> a) -> Vector a
  convert :: forall (v :: * -> *) a (w :: * -> *). (Data.Vector.Generic.Base.Vector v a, Data.Vector.Generic.Base.Vector w a) => v a -> w a
  copy :: forall a (m :: * -> *). (Unbox a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> Vector a -> m ()
  create :: forall a. Unbox a => (forall s. GHC.ST.ST s (MVector s a)) -> Vector a
  createT :: forall (f :: * -> *) a. (Data.Traversable.Traversable f, Unbox a) => (forall s. GHC.ST.ST s (f (MVector s a))) -> f (Vector a)
  drop :: forall a. Unbox a => GHC.Types.Int -> Vector a -> Vector a
  dropWhile :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> Vector a
  elem :: forall a. (Unbox a, GHC.Classes.Eq a) => a -> Vector a -> GHC.Types.Bool
  elemIndex :: forall a. (Unbox a, GHC.Classes.Eq a) => a -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  elemIndices :: forall a. (Unbox a, GHC.Classes.Eq a) => a -> Vector a -> Vector GHC.Types.Int
  empty :: forall a. Unbox a => Vector a
  enumFromN :: forall a. (Unbox a, GHC.Num.Num a) => a -> GHC.Types.Int -> Vector a
  enumFromStepN :: forall a. (Unbox a, GHC.Num.Num a) => a -> a -> GHC.Types.Int -> Vector a
  enumFromThenTo :: forall a. (Unbox a, GHC.Enum.Enum a) => a -> a -> a -> Vector a
  enumFromTo :: forall a. (Unbox a, GHC.Enum.Enum a) => a -> a -> Vector a
  eqBy :: forall a b. (Unbox a, Unbox b) => (a -> b -> GHC.Types.Bool) -> Vector a -> Vector b -> GHC.Types.Bool
  filter :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> Vector a
  filterM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Unbox a) => (a -> m GHC.Types.Bool) -> Vector a -> m (Vector a)
  find :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe a
  findIndex :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  findIndexR :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> GHC.Maybe.Maybe GHC.Types.Int
  findIndices :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> Vector GHC.Types.Int
  fold1M :: forall (m :: * -> *) a. (GHC.Base.Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m a
  fold1M' :: forall (m :: * -> *) a. (GHC.Base.Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m a
  fold1M'_ :: forall (m :: * -> *) a. (GHC.Base.Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m ()
  fold1M_ :: forall (m :: * -> *) a. (GHC.Base.Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m ()
  foldM :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m a
  foldM' :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m a
  foldM'_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m ()
  foldM_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m ()
  foldMap :: forall m a. (GHC.Base.Monoid m, Unbox a) => (a -> m) -> Vector a -> m
  foldMap' :: forall m a. (GHC.Base.Monoid m, Unbox a) => (a -> m) -> Vector a -> m
  foldl :: forall b a. Unbox b => (a -> b -> a) -> a -> Vector b -> a
  foldl' :: forall b a. Unbox b => (a -> b -> a) -> a -> Vector b -> a
  foldl1 :: forall a. Unbox a => (a -> a -> a) -> Vector a -> a
  foldl1' :: forall a. Unbox a => (a -> a -> a) -> Vector a -> a
  foldr :: forall a b. Unbox a => (a -> b -> b) -> b -> Vector a -> b
  foldr' :: forall a b. Unbox a => (a -> b -> b) -> b -> Vector a -> b
  foldr1 :: forall a. Unbox a => (a -> a -> a) -> Vector a -> a
  foldr1' :: forall a. Unbox a => (a -> a -> a) -> Vector a -> a
  forM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a, Unbox b) => Vector a -> (a -> m b) -> m (Vector b)
  forM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a) => Vector a -> (a -> m b) -> m ()
  force :: forall a. Unbox a => Vector a -> Vector a
  freeze :: forall a (m :: * -> *). (Unbox a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> m (Vector a)
  fromList :: forall a. Unbox a => [a] -> Vector a
  fromListN :: forall a. Unbox a => GHC.Types.Int -> [a] -> Vector a
  generate :: forall a. Unbox a => GHC.Types.Int -> (GHC.Types.Int -> a) -> Vector a
  generateM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Unbox a) => GHC.Types.Int -> (GHC.Types.Int -> m a) -> m (Vector a)
  group :: forall a. (Unbox a, GHC.Classes.Eq a) => Vector a -> [Vector a]
  groupBy :: forall a. Unbox a => (a -> a -> GHC.Types.Bool) -> Vector a -> [Vector a]
  head :: forall a. Unbox a => Vector a -> a
  headM :: forall a (m :: * -> *). (Unbox a, GHC.Base.Monad m) => Vector a -> m a
  ifilter :: forall a. Unbox a => (GHC.Types.Int -> a -> GHC.Types.Bool) -> Vector a -> Vector a
  ifoldM :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Unbox b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m a
  ifoldM' :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Unbox b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m a
  ifoldM'_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Unbox b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m ()
  ifoldM_ :: forall (m :: * -> *) b a. (GHC.Base.Monad m, Unbox b) => (a -> GHC.Types.Int -> b -> m a) -> a -> Vector b -> m ()
  ifoldl :: forall b a. Unbox b => (a -> GHC.Types.Int -> b -> a) -> a -> Vector b -> a
  ifoldl' :: forall b a. Unbox b => (a -> GHC.Types.Int -> b -> a) -> a -> Vector b -> a
  ifoldr :: forall a b. Unbox a => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> b
  ifoldr' :: forall a b. Unbox a => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> b
  iforM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a, Unbox b) => Vector a -> (GHC.Types.Int -> a -> m b) -> m (Vector b)
  iforM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a) => Vector a -> (GHC.Types.Int -> a -> m b) -> m ()
  imap :: forall a b. (Unbox a, Unbox b) => (GHC.Types.Int -> a -> b) -> Vector a -> Vector b
  imapM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a, Unbox b) => (GHC.Types.Int -> a -> m b) -> Vector a -> m (Vector b)
  imapM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a) => (GHC.Types.Int -> a -> m b) -> Vector a -> m ()
  imapMaybe :: forall a b. (Unbox a, Unbox b) => (GHC.Types.Int -> a -> GHC.Maybe.Maybe b) -> Vector a -> Vector b
  imapMaybeM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a, Unbox b) => (GHC.Types.Int -> a -> m (GHC.Maybe.Maybe b)) -> Vector a -> m (Vector b)
  indexM :: forall a (m :: * -> *). (Unbox a, GHC.Base.Monad m) => Vector a -> GHC.Types.Int -> m a
  indexed :: forall a. Unbox a => Vector a -> Vector (GHC.Types.Int, a)
  init :: forall a. Unbox a => Vector a -> Vector a
  iscanl :: forall a b. (Unbox a, Unbox b) => (GHC.Types.Int -> a -> b -> a) -> a -> Vector b -> Vector a
  iscanl' :: forall a b. (Unbox a, Unbox b) => (GHC.Types.Int -> a -> b -> a) -> a -> Vector b -> Vector a
  iscanr :: forall a b. (Unbox a, Unbox b) => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> Vector b
  iscanr' :: forall a b. (Unbox a, Unbox b) => (GHC.Types.Int -> a -> b -> b) -> b -> Vector a -> Vector b
  iterateN :: forall a. Unbox a => GHC.Types.Int -> (a -> a) -> a -> Vector a
  iterateNM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Unbox a) => GHC.Types.Int -> (a -> m a) -> a -> m (Vector a)
  izipWith :: forall a b c. (Unbox a, Unbox b, Unbox c) => (GHC.Types.Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c
  izipWith3 :: forall a b c d. (Unbox a, Unbox b, Unbox c, Unbox d) => (GHC.Types.Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
  izipWith4 :: forall a b c d e. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (GHC.Types.Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
  izipWith5 :: forall a b c d e f. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (GHC.Types.Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
  izipWith6 :: forall a b c d e f g. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (GHC.Types.Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
  izipWithM :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Unbox a, Unbox b, Unbox c) => (GHC.Types.Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
  izipWithM_ :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Unbox a, Unbox b) => (GHC.Types.Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()
  last :: forall a. Unbox a => Vector a -> a
  lastM :: forall a (m :: * -> *). (Unbox a, GHC.Base.Monad m) => Vector a -> m a
  length :: forall a. Unbox a => Vector a -> GHC.Types.Int
  map :: forall a b. (Unbox a, Unbox b) => (a -> b) -> Vector a -> Vector b
  mapM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a, Unbox b) => (a -> m b) -> Vector a -> m (Vector b)
  mapM_ :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a) => (a -> m b) -> Vector a -> m ()
  mapMaybe :: forall a b. (Unbox a, Unbox b) => (a -> GHC.Maybe.Maybe b) -> Vector a -> Vector b
  mapMaybeM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a, Unbox b) => (a -> m (GHC.Maybe.Maybe b)) -> Vector a -> m (Vector b)
  maxIndex :: forall a. (Unbox a, GHC.Classes.Ord a) => Vector a -> GHC.Types.Int
  maxIndexBy :: forall a. Unbox a => (a -> a -> GHC.Types.Ordering) -> Vector a -> GHC.Types.Int
  maximum :: forall a. (Unbox a, GHC.Classes.Ord a) => Vector a -> a
  maximumBy :: forall a. Unbox a => (a -> a -> GHC.Types.Ordering) -> Vector a -> a
  maximumOn :: forall b a. (GHC.Classes.Ord b, Unbox a) => (a -> b) -> Vector a -> a
  minIndex :: forall a. (Unbox a, GHC.Classes.Ord a) => Vector a -> GHC.Types.Int
  minIndexBy :: forall a. Unbox a => (a -> a -> GHC.Types.Ordering) -> Vector a -> GHC.Types.Int
  minimum :: forall a. (Unbox a, GHC.Classes.Ord a) => Vector a -> a
  minimumBy :: forall a. Unbox a => (a -> a -> GHC.Types.Ordering) -> Vector a -> a
  minimumOn :: forall b a. (GHC.Classes.Ord b, Unbox a) => (a -> b) -> Vector a -> a
  modify :: forall a. Unbox a => (forall s. MVector s a -> GHC.ST.ST s ()) -> Vector a -> Vector a
  notElem :: forall a. (Unbox a, GHC.Classes.Eq a) => a -> Vector a -> GHC.Types.Bool
  null :: forall a. Unbox a => Vector a -> GHC.Types.Bool
  or :: Vector GHC.Types.Bool -> GHC.Types.Bool
  partition :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  partitionWith :: forall a b c. (Unbox a, Unbox b, Unbox c) => (a -> Data.Either.Either b c) -> Vector a -> (Vector b, Vector c)
  postscanl :: forall a b. (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
  postscanl' :: forall a b. (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
  postscanr :: forall a b. (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
  postscanr' :: forall a b. (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
  prescanl :: forall a b. (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
  prescanl' :: forall a b. (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
  prescanr :: forall a b. (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
  prescanr' :: forall a b. (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
  product :: forall a. (Unbox a, GHC.Num.Num a) => Vector a -> a
  replicate :: forall a. Unbox a => GHC.Types.Int -> a -> Vector a
  replicateM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Unbox a) => GHC.Types.Int -> m a -> m (Vector a)
  reverse :: forall a. Unbox a => Vector a -> Vector a
  scanl :: forall a b. (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
  scanl' :: forall a b. (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
  scanl1 :: forall a. Unbox a => (a -> a -> a) -> Vector a -> Vector a
  scanl1' :: forall a. Unbox a => (a -> a -> a) -> Vector a -> Vector a
  scanr :: forall a b. (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
  scanr' :: forall a b. (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
  scanr1 :: forall a. Unbox a => (a -> a -> a) -> Vector a -> Vector a
  scanr1' :: forall a. Unbox a => (a -> a -> a) -> Vector a -> Vector a
  singleton :: forall a. Unbox a => a -> Vector a
  slice :: forall a. Unbox a => GHC.Types.Int -> GHC.Types.Int -> Vector a -> Vector a
  snoc :: forall a. Unbox a => Vector a -> a -> Vector a
  span :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  splitAt :: forall a. Unbox a => GHC.Types.Int -> Vector a -> (Vector a, Vector a)
  sum :: forall a. (Unbox a, GHC.Num.Num a) => Vector a -> a
  tail :: forall a. Unbox a => Vector a -> Vector a
  take :: forall a. Unbox a => GHC.Types.Int -> Vector a -> Vector a
  takeWhile :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> Vector a
  thaw :: forall a (m :: * -> *). (Unbox a, Control.Monad.Primitive.PrimMonad m) => Vector a -> m (MVector (Control.Monad.Primitive.PrimState m) a)
  toList :: forall a. Unbox a => Vector a -> [a]
  uncons :: forall a. Unbox a => Vector a -> GHC.Maybe.Maybe (a, Vector a)
  unfoldr :: forall a b. Unbox a => (b -> GHC.Maybe.Maybe (a, b)) -> b -> Vector a
  unfoldrExactN :: forall a b. Unbox a => GHC.Types.Int -> (b -> (a, b)) -> b -> Vector a
  unfoldrExactNM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a) => GHC.Types.Int -> (b -> m (a, b)) -> b -> m (Vector a)
  unfoldrM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a) => (b -> m (GHC.Maybe.Maybe (a, b))) -> b -> m (Vector a)
  unfoldrN :: forall a b. Unbox a => GHC.Types.Int -> (b -> GHC.Maybe.Maybe (a, b)) -> b -> Vector a
  unfoldrNM :: forall (m :: * -> *) a b. (GHC.Base.Monad m, Unbox a) => GHC.Types.Int -> (b -> m (GHC.Maybe.Maybe (a, b))) -> b -> m (Vector a)
  uniq :: forall a. (Unbox a, GHC.Classes.Eq a) => Vector a -> Vector a
  unsafeAccum :: forall a b. Unbox a => (a -> b -> a) -> Vector a -> [(GHC.Types.Int, b)] -> Vector a
  unsafeAccumulate :: forall a b. (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector (GHC.Types.Int, b) -> Vector a
  unsafeAccumulate_ :: forall a b. (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector GHC.Types.Int -> Vector b -> Vector a
  unsafeBackpermute :: forall a. Unbox a => Vector a -> Vector GHC.Types.Int -> Vector a
  unsafeCopy :: forall a (m :: * -> *). (Unbox a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> Vector a -> m ()
  unsafeDrop :: forall a. Unbox a => GHC.Types.Int -> Vector a -> Vector a
  unsafeFreeze :: forall a (m :: * -> *). (Unbox a, Control.Monad.Primitive.PrimMonad m) => MVector (Control.Monad.Primitive.PrimState m) a -> m (Vector a)
  unsafeHead :: forall a. Unbox a => Vector a -> a
  unsafeHeadM :: forall a (m :: * -> *). (Unbox a, GHC.Base.Monad m) => Vector a -> m a
  unsafeIndex :: forall a. Unbox a => Vector a -> GHC.Types.Int -> a
  unsafeIndexM :: forall a (m :: * -> *). (Unbox a, GHC.Base.Monad m) => Vector a -> GHC.Types.Int -> m a
  unsafeInit :: forall a. Unbox a => Vector a -> Vector a
  unsafeLast :: forall a. Unbox a => Vector a -> a
  unsafeLastM :: forall a (m :: * -> *). (Unbox a, GHC.Base.Monad m) => Vector a -> m a
  unsafeSlice :: forall a. Unbox a => GHC.Types.Int -> GHC.Types.Int -> Vector a -> Vector a
  unsafeTail :: forall a. Unbox a => Vector a -> Vector a
  unsafeTake :: forall a. Unbox a => GHC.Types.Int -> Vector a -> Vector a
  unsafeThaw :: forall a (m :: * -> *). (Unbox a, Control.Monad.Primitive.PrimMonad m) => Vector a -> m (MVector (Control.Monad.Primitive.PrimState m) a)
  unsafeUpd :: forall a. Unbox a => Vector a -> [(GHC.Types.Int, a)] -> Vector a
  unsafeUpdate :: forall a. Unbox a => Vector a -> Vector (GHC.Types.Int, a) -> Vector a
  unsafeUpdate_ :: forall a. Unbox a => Vector a -> Vector GHC.Types.Int -> Vector a -> Vector a
  unsnoc :: forall a. Unbox a => Vector a -> GHC.Maybe.Maybe (Vector a, a)
  unstablePartition :: forall a. Unbox a => (a -> GHC.Types.Bool) -> Vector a -> (Vector a, Vector a)
  unzip :: forall a b. (Unbox a, Unbox b) => Vector (a, b) -> (Vector a, Vector b)
  unzip3 :: forall a b c. (Unbox a, Unbox b, Unbox c) => Vector (a, b, c) -> (Vector a, Vector b, Vector c)
  unzip4 :: forall a b c d. (Unbox a, Unbox b, Unbox c, Unbox d) => Vector (a, b, c, d) -> (Vector a, Vector b, Vector c, Vector d)
  unzip5 :: forall a b c d e. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vector (a, b, c, d, e) -> (Vector a, Vector b, Vector c, Vector d, Vector e)
  unzip6 :: forall a b c d e f. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vector (a, b, c, d, e, f) -> (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)
  update :: forall a. Unbox a => Vector a -> Vector (GHC.Types.Int, a) -> Vector a
  update_ :: forall a. Unbox a => Vector a -> Vector GHC.Types.Int -> Vector a -> Vector a
  zip :: forall a b. (Unbox a, Unbox b) => Vector a -> Vector b -> Vector (a, b)
  zip3 :: forall a b c. (Unbox a, Unbox b, Unbox c) => Vector a -> Vector b -> Vector c -> Vector (a, b, c)
  zip4 :: forall a b c d. (Unbox a, Unbox b, Unbox c, Unbox d) => Vector a -> Vector b -> Vector c -> Vector d -> Vector (a, b, c, d)
  zip5 :: forall a b c d e. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector (a, b, c, d, e)
  zip6 :: forall a b c d e f. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector (a, b, c, d, e, f)
  zipWith :: forall a b c. (Unbox a, Unbox b, Unbox c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c
  zipWith3 :: forall a b c d. (Unbox a, Unbox b, Unbox c, Unbox d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
  zipWith4 :: forall a b c d e. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
  zipWith5 :: forall a b c d e f. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
  zipWith6 :: forall a b c d e f g. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
  zipWithM :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Unbox a, Unbox b, Unbox c) => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
  zipWithM_ :: forall (m :: * -> *) a b c. (GHC.Base.Monad m, Unbox a, Unbox b) => (a -> b -> m c) -> Vector a -> Vector b -> m ()

module Data.Vector.Unboxed.Base where
  type role As representational phantom
  type As :: * -> * -> *
  newtype As a b = As a
  type IOVector :: * -> *
  type IOVector = MVector GHC.Prim.RealWorld :: * -> *
  type IsoUnbox :: * -> * -> Constraint
  class IsoUnbox a b where
    toURepr :: a -> b
    default toURepr :: (GHC.Generics.Generic a, GHC.Generics.Generic b, Coercible (GHC.Generics.Rep a ()) (GHC.Generics.Rep b ())) => a -> b
    fromURepr :: b -> a
    default fromURepr :: (GHC.Generics.Generic a, GHC.Generics.Generic b, Coercible (GHC.Generics.Rep b ()) (GHC.Generics.Rep a ())) => b -> a
    {-# MINIMAL #-}
  MV_2 :: forall s a b. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s (a, b)
  MV_3 :: forall s a b c. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s (a, b, c)
  MV_4 :: forall s a b c d. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s (a, b, c, d)
  MV_5 :: forall s a b c d e. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s (a, b, c, d, e)
  MV_6 :: forall s a b c d e f. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s f -> MVector s (a, b, c, d, e, f)
  MV_All :: forall s. MVector s GHC.Types.Bool -> MVector s base-4.18.2.1:Data.Semigroup.Internal.All
  MV_Alt :: forall k s (f :: k -> *) (a :: k). MVector s (f a) -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Alt f a)
  MV_Any :: forall s. MVector s GHC.Types.Bool -> MVector s base-4.18.2.1:Data.Semigroup.Internal.Any
  MV_Arg :: forall s a b. MVector s (a, b) -> MVector s (Data.Semigroup.Arg a b)
  MV_Bool :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8 -> MVector s GHC.Types.Bool
  MV_Char :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Char -> MVector s GHC.Types.Char
  MV_Complex :: forall s a. MVector s (a, a) -> MVector s (Data.Complex.Complex a)
  MV_Compose :: forall k k1 s (f :: k -> *) (g :: k1 -> k) (a :: k1). MVector s (f (g a)) -> MVector s (Data.Functor.Compose.Compose f g a)
  MV_Const :: forall k s a (b :: k). MVector s a -> MVector s (Data.Functor.Const.Const a b)
  MV_Double :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Double -> MVector s GHC.Types.Double
  MV_Down :: forall s a. MVector s a -> MVector s (Data.Ord.Down a)
  MV_Dual :: forall s a. MVector s a -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Dual a)
  MV_First :: forall s a. MVector s a -> MVector s (Data.Semigroup.First a)
  MV_Float :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Float -> MVector s GHC.Types.Float
  MV_Identity :: forall s a. MVector s a -> MVector s (Data.Functor.Identity.Identity a)
  MV_Int :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int -> MVector s GHC.Types.Int
  MV_Int16 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int16 -> MVector s GHC.Int.Int16
  MV_Int32 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int32 -> MVector s GHC.Int.Int32
  MV_Int64 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int64 -> MVector s GHC.Int.Int64
  MV_Int8 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int8 -> MVector s GHC.Int.Int8
  MV_Last :: forall s a. MVector s a -> MVector s (Data.Semigroup.Last a)
  MV_Max :: forall s a. MVector s a -> MVector s (Data.Semigroup.Max a)
  MV_Min :: forall s a. MVector s a -> MVector s (Data.Semigroup.Min a)
  MV_Product :: forall s a. MVector s a -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Product a)
  MV_Sum :: forall s a. MVector s a -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Sum a)
  MV_UnboxAs :: forall s a b. MVector s b -> MVector s (As a b)
  MV_UnboxViaPrim :: forall s a. Data.Vector.Primitive.Mutable.MVector s a -> MVector s (UnboxViaPrim a)
  MV_Unit :: forall s. GHC.Types.Int -> MVector s ()
  MV_Word :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Word -> MVector s GHC.Types.Word
  MV_Word16 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word16 -> MVector s GHC.Word.Word16
  MV_Word32 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word32 -> MVector s GHC.Word.Word32
  MV_Word64 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word64 -> MVector s GHC.Word.Word64
  MV_Word8 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8 -> MVector s GHC.Word.Word8
  MV_WrappedMonoid :: forall s a. MVector s a -> MVector s (Data.Semigroup.WrappedMonoid a)
  type MVector :: * -> * -> *
  data family MVector s a
  type STVector :: * -> * -> *
  type STVector s = MVector s :: * -> *
  type Unbox :: * -> Constraint
  class (Data.Vector.Generic.Base.Vector Vector a, Data.Vector.Generic.Mutable.Base.MVector MVector a) => Unbox a
    {-# MINIMAL #-}
  type UnboxViaPrim :: * -> *
  newtype UnboxViaPrim a = UnboxViaPrim a
  V_2 :: forall a b. GHC.Types.Int -> Vector a -> Vector b -> Vector (a, b)
  V_3 :: forall a b c. GHC.Types.Int -> Vector a -> Vector b -> Vector c -> Vector (a, b, c)
  V_4 :: forall a b c d. GHC.Types.Int -> Vector a -> Vector b -> Vector c -> Vector d -> Vector (a, b, c, d)
  V_5 :: forall a b c d e. GHC.Types.Int -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector (a, b, c, d, e)
  V_6 :: forall a b c d e f. GHC.Types.Int -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector (a, b, c, d, e, f)
  V_All :: Vector GHC.Types.Bool -> Vector base-4.18.2.1:Data.Semigroup.Internal.All
  V_Alt :: forall k (f :: k -> *) (a :: k). Vector (f a) -> Vector (base-4.18.2.1:Data.Semigroup.Internal.Alt f a)
  V_Any :: Vector GHC.Types.Bool -> Vector base-4.18.2.1:Data.Semigroup.Internal.Any
  V_Arg :: forall a b. Vector (a, b) -> Vector (Data.Semigroup.Arg a b)
  V_Bool :: Data.Vector.Primitive.Vector GHC.Word.Word8 -> Vector GHC.Types.Bool
  V_Char :: Data.Vector.Primitive.Vector GHC.Types.Char -> Vector GHC.Types.Char
  V_Complex :: forall a. Vector (a, a) -> Vector (Data.Complex.Complex a)
  V_Compose :: forall k k1 (f :: k -> *) (g :: k1 -> k) (a :: k1). Vector (f (g a)) -> Vector (Data.Functor.Compose.Compose f g a)
  V_Const :: forall k a (b :: k). Vector a -> Vector (Data.Functor.Const.Const a b)
  V_Double :: Data.Vector.Primitive.Vector GHC.Types.Double -> Vector GHC.Types.Double
  V_Down :: forall a. Vector a -> Vector (Data.Ord.Down a)
  V_Dual :: forall a. Vector a -> Vector (base-4.18.2.1:Data.Semigroup.Internal.Dual a)
  V_First :: forall a. Vector a -> Vector (Data.Semigroup.First a)
  V_Float :: Data.Vector.Primitive.Vector GHC.Types.Float -> Vector GHC.Types.Float
  V_Identity :: forall a. Vector a -> Vector (Data.Functor.Identity.Identity a)
  V_Int :: Data.Vector.Primitive.Vector GHC.Types.Int -> Vector GHC.Types.Int
  V_Int16 :: Data.Vector.Primitive.Vector GHC.Int.Int16 -> Vector GHC.Int.Int16
  V_Int32 :: Data.Vector.Primitive.Vector GHC.Int.Int32 -> Vector GHC.Int.Int32
  V_Int64 :: Data.Vector.Primitive.Vector GHC.Int.Int64 -> Vector GHC.Int.Int64
  V_Int8 :: Data.Vector.Primitive.Vector GHC.Int.Int8 -> Vector GHC.Int.Int8
  V_Last :: forall a. Vector a -> Vector (Data.Semigroup.Last a)
  V_Max :: forall a. Vector a -> Vector (Data.Semigroup.Max a)
  V_Min :: forall a. Vector a -> Vector (Data.Semigroup.Min a)
  V_Product :: forall a. Vector a -> Vector (base-4.18.2.1:Data.Semigroup.Internal.Product a)
  V_Sum :: forall a. Vector a -> Vector (base-4.18.2.1:Data.Semigroup.Internal.Sum a)
  V_UnboxAs :: forall a b. Vector b -> Vector (As a b)
  V_UnboxViaPrim :: forall a. Data.Vector.Primitive.Vector a -> Vector (UnboxViaPrim a)
  V_Unit :: GHC.Types.Int -> Vector ()
  V_Word :: Data.Vector.Primitive.Vector GHC.Types.Word -> Vector GHC.Types.Word
  V_Word16 :: Data.Vector.Primitive.Vector GHC.Word.Word16 -> Vector GHC.Word.Word16
  V_Word32 :: Data.Vector.Primitive.Vector GHC.Word.Word32 -> Vector GHC.Word.Word32
  V_Word64 :: Data.Vector.Primitive.Vector GHC.Word.Word64 -> Vector GHC.Word.Word64
  V_Word8 :: Data.Vector.Primitive.Vector GHC.Word.Word8 -> Vector GHC.Word.Word8
  V_WrappedMonoid :: forall a. Vector a -> Vector (Data.Semigroup.WrappedMonoid a)
  type Vector :: * -> *
  data family Vector a

module Data.Vector.Unboxed.Mutable where
  type IOVector :: * -> *
  type IOVector = MVector RealWorld :: * -> *
  MV_2 :: forall s a b. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s (a, b)
  MV_3 :: forall s a b c. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s (a, b, c)
  MV_4 :: forall s a b c d. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s (a, b, c, d)
  MV_5 :: forall s a b c d e. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s (a, b, c, d, e)
  MV_6 :: forall s a b c d e f. GHC.Types.Int -> MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s f -> MVector s (a, b, c, d, e, f)
  MV_All :: forall s. MVector s GHC.Types.Bool -> MVector s base-4.18.2.1:Data.Semigroup.Internal.All
  MV_Alt :: forall k s (f :: k -> *) (a :: k). MVector s (f a) -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Alt f a)
  MV_Any :: forall s. MVector s GHC.Types.Bool -> MVector s base-4.18.2.1:Data.Semigroup.Internal.Any
  MV_Arg :: forall s a b. MVector s (a, b) -> MVector s (Data.Semigroup.Arg a b)
  MV_Bool :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8 -> MVector s GHC.Types.Bool
  MV_Char :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Char -> MVector s GHC.Types.Char
  MV_Complex :: forall s a. MVector s (a, a) -> MVector s (Data.Complex.Complex a)
  MV_Compose :: forall k k1 s (f :: k -> *) (g :: k1 -> k) (a :: k1). MVector s (f (g a)) -> MVector s (Data.Functor.Compose.Compose f g a)
  MV_Const :: forall k s a (b :: k). MVector s a -> MVector s (Data.Functor.Const.Const a b)
  MV_Double :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Double -> MVector s GHC.Types.Double
  MV_Down :: forall s a. MVector s a -> MVector s (Data.Ord.Down a)
  MV_Dual :: forall s a. MVector s a -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Dual a)
  MV_First :: forall s a. MVector s a -> MVector s (Data.Semigroup.First a)
  MV_Float :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Float -> MVector s GHC.Types.Float
  MV_Identity :: forall s a. MVector s a -> MVector s (Data.Functor.Identity.Identity a)
  MV_Int :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int -> MVector s GHC.Types.Int
  MV_Int16 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int16 -> MVector s GHC.Int.Int16
  MV_Int32 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int32 -> MVector s GHC.Int.Int32
  MV_Int64 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int64 -> MVector s GHC.Int.Int64
  MV_Int8 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Int.Int8 -> MVector s GHC.Int.Int8
  MV_Last :: forall s a. MVector s a -> MVector s (Data.Semigroup.Last a)
  MV_Max :: forall s a. MVector s a -> MVector s (Data.Semigroup.Max a)
  MV_Min :: forall s a. MVector s a -> MVector s (Data.Semigroup.Min a)
  MV_Product :: forall s a. MVector s a -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Product a)
  MV_Sum :: forall s a. MVector s a -> MVector s (base-4.18.2.1:Data.Semigroup.Internal.Sum a)
  MV_UnboxAs :: forall s a b. MVector s b -> MVector s (Data.Vector.Unboxed.Base.As a b)
  MV_UnboxViaPrim :: forall s a. Data.Vector.Primitive.Mutable.MVector s a -> MVector s (Data.Vector.Unboxed.Base.UnboxViaPrim a)
  MV_Unit :: forall s. GHC.Types.Int -> MVector s ()
  MV_Word :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Types.Word -> MVector s GHC.Types.Word
  MV_Word16 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word16 -> MVector s GHC.Word.Word16
  MV_Word32 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word32 -> MVector s GHC.Word.Word32
  MV_Word64 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word64 -> MVector s GHC.Word.Word64
  MV_Word8 :: forall s. Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8 -> MVector s GHC.Word.Word8
  MV_WrappedMonoid :: forall s a. MVector s a -> MVector s (Data.Semigroup.WrappedMonoid a)
  type MVector :: * -> * -> *
  data family MVector s a
  type PrimMonad :: (* -> *) -> Constraint
  class GHC.Base.Monad m => PrimMonad m where
    type PrimState :: (* -> *) -> *
    type family PrimState m
    Control.Monad.Primitive.primitive :: forall a. (GHC.Prim.State# (PrimState m) -> (# GHC.Prim.State# (PrimState m), a #)) -> m a
    {-# MINIMAL primitive #-}
    {-# MINIMAL Control.Monad.Primitive.primitive #-}
  type RealWorld :: *
  data RealWorld
  type STVector :: * -> * -> *
  type STVector s = MVector s :: * -> *
  type Unbox :: * -> Constraint
  class (Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector a, Data.Vector.Generic.Mutable.Base.MVector MVector a) => Unbox a
    {-# MINIMAL #-}
  clear :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> m ()
  clone :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> m (MVector (PrimState m) a)
  copy :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  drop :: forall a s. Unbox a => GHC.Types.Int -> MVector s a -> MVector s a
  exchange :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m a
  foldM :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  foldM' :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  foldl :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b
  foldl' :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b
  foldr :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  foldr' :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  foldrM :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  foldrM' :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  forM_ :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> m b) -> m ()
  generate :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => GHC.Types.Int -> (GHC.Types.Int -> a) -> m (MVector (PrimState m) a)
  generateM :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => GHC.Types.Int -> (GHC.Types.Int -> m a) -> m (MVector (PrimState m) a)
  grow :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> GHC.Types.Int -> m (MVector (PrimState m) a)
  ifoldM :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (b -> GHC.Types.Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldM' :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (b -> GHC.Types.Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldl :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (b -> GHC.Types.Int -> a -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldl' :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (b -> GHC.Types.Int -> a -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldr :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (GHC.Types.Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldr' :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (GHC.Types.Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b
  ifoldrM :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (GHC.Types.Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  ifoldrM' :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (GHC.Types.Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b
  iforM_ :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (GHC.Types.Int -> a -> m b) -> m ()
  imapM_ :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (GHC.Types.Int -> a -> m b) -> MVector (PrimState m) a -> m ()
  init :: forall a s. Unbox a => MVector s a -> MVector s a
  length :: forall a s. Unbox a => MVector s a -> GHC.Types.Int
  mapM_ :: forall (m :: * -> *) a b. (PrimMonad m, Unbox a) => (a -> m b) -> MVector (PrimState m) a -> m ()
  modify :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> a) -> GHC.Types.Int -> m ()
  modifyM :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> m a) -> GHC.Types.Int -> m ()
  move :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  new :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => GHC.Types.Int -> m (MVector (PrimState m) a)
  nextPermutation :: forall (m :: * -> *) e. (PrimMonad m, GHC.Classes.Ord e, Unbox e) => MVector (PrimState m) e -> m GHC.Types.Bool
  null :: forall a s. Unbox a => MVector s a -> GHC.Types.Bool
  overlaps :: forall a s. Unbox a => MVector s a -> MVector s a -> GHC.Types.Bool
  read :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> GHC.Types.Int -> m a
  readMaybe :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> GHC.Types.Int -> m (GHC.Maybe.Maybe a)
  replicate :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => GHC.Types.Int -> a -> m (MVector (PrimState m) a)
  replicateM :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => GHC.Types.Int -> m a -> m (MVector (PrimState m) a)
  set :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> a -> m ()
  slice :: forall a s. Unbox a => GHC.Types.Int -> GHC.Types.Int -> MVector s a -> MVector s a
  splitAt :: forall a s. Unbox a => GHC.Types.Int -> MVector s a -> (MVector s a, MVector s a)
  swap :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> GHC.Types.Int -> GHC.Types.Int -> m ()
  tail :: forall a s. Unbox a => MVector s a -> MVector s a
  take :: forall a s. Unbox a => GHC.Types.Int -> MVector s a -> MVector s a
  unsafeCopy :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  unsafeDrop :: forall a s. Unbox a => GHC.Types.Int -> MVector s a -> MVector s a
  unsafeExchange :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m a
  unsafeGrow :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> GHC.Types.Int -> m (MVector (PrimState m) a)
  unsafeInit :: forall a s. Unbox a => MVector s a -> MVector s a
  unsafeModify :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> a) -> GHC.Types.Int -> m ()
  unsafeModifyM :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> m a) -> GHC.Types.Int -> m ()
  unsafeMove :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
  unsafeNew :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => GHC.Types.Int -> m (MVector (PrimState m) a)
  unsafeRead :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> GHC.Types.Int -> m a
  unsafeSlice :: forall a s. Unbox a => GHC.Types.Int -> GHC.Types.Int -> MVector s a -> MVector s a
  unsafeSwap :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> GHC.Types.Int -> GHC.Types.Int -> m ()
  unsafeTail :: forall a s. Unbox a => MVector s a -> MVector s a
  unsafeTake :: forall a s. Unbox a => GHC.Types.Int -> MVector s a -> MVector s a
  unsafeWrite :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m ()
  unzip :: forall a b s. (Unbox a, Unbox b) => MVector s (a, b) -> (MVector s a, MVector s b)
  unzip3 :: forall a b c s. (Unbox a, Unbox b, Unbox c) => MVector s (a, b, c) -> (MVector s a, MVector s b, MVector s c)
  unzip4 :: forall a b c d s. (Unbox a, Unbox b, Unbox c, Unbox d) => MVector s (a, b, c, d) -> (MVector s a, MVector s b, MVector s c, MVector s d)
  unzip5 :: forall a b c d e s. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => MVector s (a, b, c, d, e) -> (MVector s a, MVector s b, MVector s c, MVector s d, MVector s e)
  unzip6 :: forall a b c d e f s. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => MVector s (a, b, c, d, e, f) -> (MVector s a, MVector s b, MVector s c, MVector s d, MVector s e, MVector s f)
  write :: forall (m :: * -> *) a. (PrimMonad m, Unbox a) => MVector (PrimState m) a -> GHC.Types.Int -> a -> m ()
  zip :: forall a b s. (Unbox a, Unbox b) => MVector s a -> MVector s b -> MVector s (a, b)
  zip3 :: forall a b c s. (Unbox a, Unbox b, Unbox c) => MVector s a -> MVector s b -> MVector s c -> MVector s (a, b, c)
  zip4 :: forall a b c d s. (Unbox a, Unbox b, Unbox c, Unbox d) => MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s (a, b, c, d)
  zip5 :: forall a b c d e s. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s (a, b, c, d, e)
  zip6 :: forall a b c d e f s. (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s f -> MVector s (a, b, c, d, e, f)


-- Instances:
instance Control.Monad.Fail.MonadFail Data.Vector.Vector -- Defined in ‘Data.Vector’
instance Control.Monad.Fix.MonadFix Data.Vector.Vector -- Defined in ‘Data.Vector’
instance Control.Monad.Zip.MonadZip Data.Vector.Vector -- Defined in ‘Data.Vector’
instance forall a. Data.Data.Data a => Data.Data.Data (Data.Vector.Vector a) -- Defined in ‘Data.Vector’
instance forall a. (Data.Data.Data a, Data.Primitive.Types.Prim a) => Data.Data.Data (Data.Vector.Primitive.Vector a) -- Defined in ‘Data.Vector.Primitive’
instance forall a. (Data.Data.Data a, Foreign.Storable.Storable a) => Data.Data.Data (Data.Vector.Storable.Vector a) -- Defined in ‘Data.Vector.Storable’
instance forall a. (Data.Data.Data a, Data.Vector.Unboxed.Base.Unbox a) => Data.Data.Data (Data.Vector.Unboxed.Base.Vector a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Foldable.Foldable Data.Vector.Vector -- Defined in ‘Data.Vector’
instance Data.Functor.Classes.Eq1 Data.Vector.Vector -- Defined in ‘Data.Vector’
instance forall (v :: * -> *). Data.Functor.Classes.Eq1 (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v) -- Defined in ‘Data.Vector.Fusion.Bundle’
instance Data.Functor.Classes.Ord1 Data.Vector.Vector -- Defined in ‘Data.Vector’
instance forall (v :: * -> *). Data.Functor.Classes.Ord1 (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v) -- Defined in ‘Data.Vector.Fusion.Bundle’
instance Data.Functor.Classes.Read1 Data.Vector.Vector -- Defined in ‘Data.Vector’
instance Data.Functor.Classes.Show1 Data.Vector.Vector -- Defined in ‘Data.Vector’
instance Data.Traversable.Traversable Data.Vector.Vector -- Defined in ‘Data.Vector’
instance forall a. Data.Primitive.Types.Prim a => Foreign.Storable.Storable (Data.Primitive.Types.PrimStorable a) -- Defined in ‘Data.Primitive.Types’
instance Foreign.Storable.Storable () -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Bool -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Char -- Defined in ‘Foreign.Storable’
instance forall a. Foreign.Storable.Storable (Foreign.C.ConstPtr.ConstPtr a) -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Double -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Fingerprint.Type.Fingerprint -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Float -- Defined in ‘Foreign.Storable’
instance forall a. Foreign.Storable.Storable (GHC.Ptr.FunPtr a) -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Int -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int16 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int32 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int64 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int8 -- Defined in ‘Foreign.Storable’
instance forall a. Foreign.Storable.Storable (GHC.Ptr.Ptr a) -- Defined in ‘Foreign.Storable’
instance forall a. (Foreign.Storable.Storable a, GHC.Real.Integral a) => Foreign.Storable.Storable (GHC.Real.Ratio a) -- Defined in ‘Foreign.Storable’
instance forall a. Foreign.Storable.Storable (GHC.Stable.StablePtr a) -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Word -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word16 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word32 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word64 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word8 -- Defined in ‘Foreign.Storable’
instance GHC.Base.Alternative Data.Vector.Vector -- Defined in ‘Data.Vector’
instance GHC.Base.Applicative Data.Vector.Vector -- Defined in ‘Data.Vector’
instance GHC.Base.Applicative Data.Stream.Monadic.Box -- Defined in ‘Data.Stream.Monadic’
instance GHC.Base.Applicative Data.Vector.Fusion.Util.Id -- Defined in ‘Data.Vector.Fusion.Util’
instance GHC.Base.Functor Data.Vector.Vector -- Defined in ‘Data.Vector’
instance forall (m :: * -> *) (v :: * -> *). GHC.Base.Monad m => GHC.Base.Functor (Data.Vector.Fusion.Bundle.Monadic.Bundle m v) -- Defined in ‘Data.Vector.Fusion.Bundle.Monadic’
instance GHC.Base.Functor Data.Stream.Monadic.Box -- Defined in ‘Data.Stream.Monadic’
instance forall s. GHC.Base.Functor (Data.Stream.Monadic.Step s) -- Defined in ‘Data.Stream.Monadic’
instance forall (m :: * -> *). GHC.Base.Monad m => GHC.Base.Functor (Data.Stream.Monadic.Stream m) -- Defined in ‘Data.Stream.Monadic’
instance GHC.Base.Functor Data.Vector.Fusion.Util.Id -- Defined in ‘Data.Vector.Fusion.Util’
instance GHC.Base.Monad Data.Vector.Vector -- Defined in ‘Data.Vector’
instance GHC.Base.Monad Data.Stream.Monadic.Box -- Defined in ‘Data.Stream.Monadic’
instance GHC.Base.Monad Data.Vector.Fusion.Util.Id -- Defined in ‘Data.Vector.Fusion.Util’
instance GHC.Base.MonadPlus Data.Vector.Vector -- Defined in ‘Data.Vector’
instance forall a. GHC.Base.Monoid (Data.Vector.Vector a) -- Defined in ‘Data.Vector’
instance forall a. Data.Primitive.Types.Prim a => GHC.Base.Monoid (Data.Vector.Primitive.Vector a) -- Defined in ‘Data.Vector.Primitive’
instance forall a. Foreign.Storable.Storable a => GHC.Base.Monoid (Data.Vector.Storable.Vector a) -- Defined in ‘Data.Vector.Storable’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => GHC.Base.Monoid (Data.Vector.Unboxed.Base.Vector a) -- Defined in ‘Data.Vector.Unboxed’
instance forall a. GHC.Base.Semigroup (Data.Vector.Vector a) -- Defined in ‘Data.Vector’
instance forall a. Data.Primitive.Types.Prim a => GHC.Base.Semigroup (Data.Vector.Primitive.Vector a) -- Defined in ‘Data.Vector.Primitive’
instance forall a. Foreign.Storable.Storable a => GHC.Base.Semigroup (Data.Vector.Storable.Vector a) -- Defined in ‘Data.Vector.Storable’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => GHC.Base.Semigroup (Data.Vector.Unboxed.Base.Vector a) -- Defined in ‘Data.Vector.Unboxed’
instance forall a. GHC.IsList.IsList (Data.Vector.Vector a) -- Defined in ‘Data.Vector’
instance forall a. Data.Primitive.Types.Prim a => GHC.IsList.IsList (Data.Vector.Primitive.Vector a) -- Defined in ‘Data.Vector.Primitive’
instance forall a. Foreign.Storable.Storable a => GHC.IsList.IsList (Data.Vector.Storable.Vector a) -- Defined in ‘Data.Vector.Storable’
instance forall e. Data.Vector.Unboxed.Base.Unbox e => GHC.IsList.IsList (Data.Vector.Unboxed.Base.Vector e) -- Defined in ‘Data.Vector.Unboxed’
instance GHC.Num.Num Data.Vector.Fusion.Bundle.Size.Size -- Defined in ‘Data.Vector.Fusion.Bundle.Size’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Vector.Vector a) -- Defined in ‘Data.Vector’
instance forall a. (GHC.Read.Read a, Data.Primitive.Types.Prim a) => GHC.Read.Read (Data.Vector.Primitive.Vector a) -- Defined in ‘Data.Vector.Primitive’
instance forall a. (GHC.Read.Read a, Foreign.Storable.Storable a) => GHC.Read.Read (Data.Vector.Storable.Vector a) -- Defined in ‘Data.Vector.Storable’
instance forall a. (GHC.Read.Read a, Data.Vector.Unboxed.Base.Unbox a) => GHC.Read.Read (Data.Vector.Unboxed.Base.Vector a) -- Defined in ‘Data.Vector.Unboxed’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Vector.Vector a) -- Defined in ‘Data.Vector’
instance GHC.Show.Show Data.Vector.Fusion.Bundle.Size.Size -- Defined in ‘Data.Vector.Fusion.Bundle.Size’
instance forall a. (GHC.Show.Show a, Data.Primitive.Types.Prim a) => GHC.Show.Show (Data.Vector.Primitive.Vector a) -- Defined in ‘Data.Vector.Primitive’
instance forall a. (GHC.Show.Show a, Foreign.Storable.Storable a) => GHC.Show.Show (Data.Vector.Storable.Vector a) -- Defined in ‘Data.Vector.Storable’
instance forall a. GHC.Show.Show (GHC.ForeignPtr.ForeignPtr a) -- Defined in ‘GHC.ForeignPtr’
instance forall a. (GHC.Show.Show a, Data.Vector.Unboxed.Base.Unbox a) => GHC.Show.Show (Data.Vector.Unboxed.Base.Vector a) -- Defined in ‘Data.Vector.Unboxed’
instance forall a. Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Vector.Vector a) -- Defined in ‘Data.Vector’
instance forall a. Control.DeepSeq.NFData (Data.Vector.Primitive.Vector a) -- Defined in ‘Data.Vector.Primitive’
instance forall s a. Control.DeepSeq.NFData (Data.Vector.Primitive.Mutable.MVector s a) -- Defined in ‘Data.Vector.Primitive.Mutable’
instance forall a. Control.DeepSeq.NFData (Data.Vector.Storable.Vector a) -- Defined in ‘Data.Vector.Storable’
instance forall s a. Control.DeepSeq.NFData (Data.Vector.Storable.Mutable.MVector s a) -- Defined in ‘Data.Vector.Storable.Mutable’
instance forall s a. Control.DeepSeq.NFData (Data.Vector.Unboxed.Base.MVector s a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Control.DeepSeq.NFData (Data.Vector.Unboxed.Base.Vector a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Control.DeepSeq.NFData1 Data.Vector.Vector -- Defined in ‘Data.Vector’
instance Control.DeepSeq.NFData1 Data.Vector.Primitive.Vector -- Defined in ‘Data.Vector.Primitive’
instance forall s. Control.DeepSeq.NFData1 (Data.Vector.Primitive.Mutable.MVector s) -- Defined in ‘Data.Vector.Primitive.Mutable’
instance Control.DeepSeq.NFData1 Data.Vector.Storable.Vector -- Defined in ‘Data.Vector.Storable’
instance forall s. Control.DeepSeq.NFData1 (Data.Vector.Storable.Mutable.MVector s) -- Defined in ‘Data.Vector.Storable.Mutable’
instance forall s. Control.DeepSeq.NFData1 (Data.Vector.Unboxed.Base.MVector s) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Control.DeepSeq.NFData1 Data.Vector.Unboxed.Base.Vector -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Vector.Vector a) -- Defined in ‘Data.Vector’
instance forall a (v :: * -> *). GHC.Classes.Eq a => GHC.Classes.Eq (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v a) -- Defined in ‘Data.Vector.Fusion.Bundle’
instance GHC.Classes.Eq Data.Vector.Fusion.Bundle.Size.Size -- Defined in ‘Data.Vector.Fusion.Bundle.Size’
instance forall a. (Data.Primitive.Types.Prim a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Primitive.Vector a) -- Defined in ‘Data.Vector.Primitive’
instance forall a. (Foreign.Storable.Storable a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Storable.Vector a) -- Defined in ‘Data.Vector.Storable’
instance forall a. GHC.Classes.Eq (GHC.ForeignPtr.ForeignPtr a) -- Defined in ‘GHC.ForeignPtr’
instance forall a. (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Unboxed.Base.Vector a) -- Defined in ‘Data.Vector.Unboxed’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Data.Vector.Vector a) -- Defined in ‘Data.Vector’
instance forall a (v :: * -> *). GHC.Classes.Ord a => GHC.Classes.Ord (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v a) -- Defined in ‘Data.Vector.Fusion.Bundle’
instance forall a. (Data.Primitive.Types.Prim a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Primitive.Vector a) -- Defined in ‘Data.Vector.Primitive’
instance forall a. (Foreign.Storable.Storable a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Storable.Vector a) -- Defined in ‘Data.Vector.Storable’
instance forall a. GHC.Classes.Ord (GHC.ForeignPtr.ForeignPtr a) -- Defined in ‘GHC.ForeignPtr’
instance forall a. (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Unboxed.Base.Vector a) -- Defined in ‘Data.Vector.Unboxed’
instance forall (m :: * -> *) s. (Control.Monad.Primitive.PrimMonad m, s ~ Control.Monad.Primitive.PrimState m) => Control.Monad.Primitive.MonadPrim s m -- Defined in ‘Control.Monad.Primitive’
instance forall (m :: * -> *) s. (Control.Monad.Primitive.PrimBase m, Control.Monad.Primitive.MonadPrim s m) => Control.Monad.Primitive.MonadPrimBase s m -- Defined in ‘Control.Monad.Primitive’
instance Control.Monad.Primitive.PrimBase GHC.Types.IO -- Defined in ‘Control.Monad.Primitive’
instance forall s. Control.Monad.Primitive.PrimBase (base-4.18.2.1:Control.Monad.ST.Lazy.Imp.ST s) -- Defined in ‘Control.Monad.Primitive’
instance forall s. Control.Monad.Primitive.PrimBase (GHC.ST.ST s) -- Defined in ‘Control.Monad.Primitive’
instance forall w (m :: * -> *). (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Accum.AccumT w m) -- Defined in ‘Control.Monad.Primitive’
instance forall (m :: * -> *) e. Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Except.ExceptT e m) -- Defined in ‘Control.Monad.Primitive’
instance Control.Monad.Primitive.PrimMonad GHC.Types.IO -- Defined in ‘Control.Monad.Primitive’
instance forall (m :: * -> *). Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Maybe.MaybeT m) -- Defined in ‘Control.Monad.Primitive’
instance forall w (m :: * -> *) r s. (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.RWS.Strict.RWST r w s m) -- Defined in ‘Control.Monad.Primitive’
instance forall w (m :: * -> *) r s. (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.RWS.CPS.RWST r w s m) -- Defined in ‘Control.Monad.Primitive’
instance forall w (m :: * -> *) r s. (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.RWS.Lazy.RWST r w s m) -- Defined in ‘Control.Monad.Primitive’
instance forall (m :: * -> *) r. Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Reader.ReaderT r m) -- Defined in ‘Control.Monad.Primitive’
instance forall s. Control.Monad.Primitive.PrimMonad (base-4.18.2.1:Control.Monad.ST.Lazy.Imp.ST s) -- Defined in ‘Control.Monad.Primitive’
instance forall s. Control.Monad.Primitive.PrimMonad (GHC.ST.ST s) -- Defined in ‘Control.Monad.Primitive’
instance forall (m :: * -> *) r. Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Select.SelectT r m) -- Defined in ‘Control.Monad.Primitive’
instance forall (m :: * -> *) s. Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.State.Strict.StateT s m) -- Defined in ‘Control.Monad.Primitive’
instance forall (m :: * -> *) s. Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.State.Lazy.StateT s m) -- Defined in ‘Control.Monad.Primitive’
instance forall w (m :: * -> *). (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Writer.Strict.WriterT w m) -- Defined in ‘Control.Monad.Primitive’
instance forall w (m :: * -> *). (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Writer.CPS.WriterT w m) -- Defined in ‘Control.Monad.Primitive’
instance forall w (m :: * -> *). (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Writer.Lazy.WriterT w m) -- Defined in ‘Control.Monad.Primitive’
instance Data.Primitive.Types.Prim GHC.Types.Char -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (Data.Complex.Complex a) -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Types.Double -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (Data.Ord.Down a) -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (base-4.18.2.1:Data.Semigroup.Internal.Dual a) -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (Data.Semigroup.First a) -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Types.Float -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim (GHC.Ptr.FunPtr a) -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Types.Int -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Int.Int16 -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Int.Int32 -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Int.Int64 -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Int.Int8 -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim Foreign.Ptr.IntPtr -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (Data.Semigroup.Last a) -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (Data.Semigroup.Max a) -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (Data.Semigroup.Min a) -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (base-4.18.2.1:Data.Semigroup.Internal.Product a) -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim (GHC.Ptr.Ptr a) -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim (GHC.Stable.StablePtr a) -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (base-4.18.2.1:Data.Semigroup.Internal.Sum a) -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Types.Word -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Word.Word16 -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Word.Word32 -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Word.Word64 -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim GHC.Word.Word8 -- Defined in ‘Data.Primitive.Types’
instance Data.Primitive.Types.Prim Foreign.Ptr.WordPtr -- Defined in ‘Data.Primitive.Types’
instance forall a. Data.Vector.Generic.Base.Vector Data.Vector.Vector a -- Defined in ‘Data.Vector’
instance forall a. Data.Primitive.Types.Prim a => Data.Vector.Generic.Base.Vector Data.Vector.Primitive.Vector a -- Defined in ‘Data.Vector.Primitive’
instance forall a. Foreign.Storable.Storable a => Data.Vector.Generic.Base.Vector Data.Vector.Storable.Vector a -- Defined in ‘Data.Vector.Storable’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector () -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (a, b) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (a, b, c) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c d. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c, Data.Vector.Unboxed.Base.Unbox d) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (a, b, c, d) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c d e. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c, Data.Vector.Unboxed.Base.Unbox d, Data.Vector.Unboxed.Base.Unbox e) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (a, b, c, d, e) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c d e f. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c, Data.Vector.Unboxed.Base.Unbox d, Data.Vector.Unboxed.Base.Unbox e, Data.Vector.Unboxed.Base.Unbox f) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (a, b, c, d, e, f) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector base-4.18.2.1:Data.Semigroup.Internal.All -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall k (f :: k -> *) (a :: k). Data.Vector.Unboxed.Base.Unbox (f a) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (base-4.18.2.1:Data.Semigroup.Internal.Alt f a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector base-4.18.2.1:Data.Semigroup.Internal.Any -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Arg a b) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b. (Data.Vector.Unboxed.Base.IsoUnbox a b, Data.Vector.Unboxed.Base.Unbox b) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Vector.Unboxed.Base.As a b) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Types.Bool -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Types.Char -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Complex.Complex a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall k k1 (f :: k -> *) (g :: k1 -> k) (a :: k1). Data.Vector.Unboxed.Base.Unbox (f (g a)) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall k a (b :: k). Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Functor.Const.Const a b) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Types.Double -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Ord.Down a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (base-4.18.2.1:Data.Semigroup.Internal.Dual a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Semigroup.First a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Types.Float -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Types.Int -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Int.Int16 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Int.Int32 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Int.Int64 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Int.Int8 -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Last a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Max a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Min a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (base-4.18.2.1:Data.Semigroup.Internal.Product a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (base-4.18.2.1:Data.Semigroup.Internal.Sum a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Primitive.Types.Prim a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Vector.Unboxed.Base.UnboxViaPrim a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Types.Word -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Word.Word16 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Word.Word32 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Word.Word64 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector GHC.Word.Word8 -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Semigroup.WrappedMonoid a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Mutable.MVector a -- Defined in ‘Data.Vector.Mutable’
instance forall a. Data.Primitive.Types.Prim a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Primitive.Mutable.MVector a -- Defined in ‘Data.Vector.Primitive.Mutable’
instance forall a. Foreign.Storable.Storable a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Storable.Mutable.MVector a -- Defined in ‘Data.Vector.Storable.Mutable’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector () -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (a, b) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (a, b, c) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c d. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c, Data.Vector.Unboxed.Base.Unbox d) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (a, b, c, d) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c d e. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c, Data.Vector.Unboxed.Base.Unbox d, Data.Vector.Unboxed.Base.Unbox e) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (a, b, c, d, e) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c d e f. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c, Data.Vector.Unboxed.Base.Unbox d, Data.Vector.Unboxed.Base.Unbox e, Data.Vector.Unboxed.Base.Unbox f) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (a, b, c, d, e, f) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector base-4.18.2.1:Data.Semigroup.Internal.All -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall k (f :: k -> *) (a :: k). Data.Vector.Unboxed.Base.Unbox (f a) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (base-4.18.2.1:Data.Semigroup.Internal.Alt f a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector base-4.18.2.1:Data.Semigroup.Internal.Any -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Semigroup.Arg a b) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b. (Data.Vector.Unboxed.Base.IsoUnbox a b, Data.Vector.Unboxed.Base.Unbox b) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Vector.Unboxed.Base.As a b) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Types.Bool -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Types.Char -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Complex.Complex a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall k k1 (f :: k -> *) (g :: k1 -> k) (a :: k1). Data.Vector.Unboxed.Base.Unbox (f (g a)) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall k a (b :: k). Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Functor.Const.Const a b) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Types.Double -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Ord.Down a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (base-4.18.2.1:Data.Semigroup.Internal.Dual a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Semigroup.First a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Types.Float -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Types.Int -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Int.Int16 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Int.Int32 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Int.Int64 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Int.Int8 -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Semigroup.Last a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Semigroup.Max a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Semigroup.Min a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (base-4.18.2.1:Data.Semigroup.Internal.Product a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (base-4.18.2.1:Data.Semigroup.Internal.Sum a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Primitive.Types.Prim a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Vector.Unboxed.Base.UnboxViaPrim a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Types.Word -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Word.Word16 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Word.Word32 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Word.Word64 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector GHC.Word.Word8 -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Semigroup.WrappedMonoid a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox () -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Data.Vector.Unboxed.Base.Unbox (a, b) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c) => Data.Vector.Unboxed.Base.Unbox (a, b, c) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c d. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c, Data.Vector.Unboxed.Base.Unbox d) => Data.Vector.Unboxed.Base.Unbox (a, b, c, d) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c d e. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c, Data.Vector.Unboxed.Base.Unbox d, Data.Vector.Unboxed.Base.Unbox e) => Data.Vector.Unboxed.Base.Unbox (a, b, c, d, e) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b c d e f. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b, Data.Vector.Unboxed.Base.Unbox c, Data.Vector.Unboxed.Base.Unbox d, Data.Vector.Unboxed.Base.Unbox e, Data.Vector.Unboxed.Base.Unbox f) => Data.Vector.Unboxed.Base.Unbox (a, b, c, d, e, f) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox base-4.18.2.1:Data.Semigroup.Internal.All -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall k (f :: k -> *) (a :: k). Data.Vector.Unboxed.Base.Unbox (f a) => Data.Vector.Unboxed.Base.Unbox (base-4.18.2.1:Data.Semigroup.Internal.Alt f a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox base-4.18.2.1:Data.Semigroup.Internal.Any -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a b. (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Data.Vector.Unboxed.Base.Unbox (Data.Semigroup.Arg a b) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Types.Bool -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Types.Char -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Data.Complex.Complex a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall k k1 (f :: k -> *) (g :: k1 -> k) (a :: k1). Data.Vector.Unboxed.Base.Unbox (f (g a)) => Data.Vector.Unboxed.Base.Unbox (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall k a (b :: k). Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Data.Functor.Const.Const a b) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Types.Double -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Data.Ord.Down a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (base-4.18.2.1:Data.Semigroup.Internal.Dual a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Data.Semigroup.First a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Types.Float -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Types.Int -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Int.Int16 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Int.Int32 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Int.Int64 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Int.Int8 -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Data.Semigroup.Last a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Data.Semigroup.Max a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Data.Semigroup.Min a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (base-4.18.2.1:Data.Semigroup.Internal.Product a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (base-4.18.2.1:Data.Semigroup.Internal.Sum a) -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Types.Word -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Word.Word16 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Word.Word32 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Word.Word64 -- Defined in ‘Data.Vector.Unboxed.Base’
instance Data.Vector.Unboxed.Base.Unbox GHC.Word.Word8 -- Defined in ‘Data.Vector.Unboxed.Base’
instance forall a. Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Data.Semigroup.WrappedMonoid a) -- Defined in ‘Data.Vector.Unboxed.Base’