module Servant.Client where
  (//) :: forall a b. a -> (a -> b) -> b
  (/:) :: forall a b c. (a -> b -> c) -> b -> a -> c
  type role AsClientT phantom
  type AsClientT :: (* -> *) -> *
  data AsClientT m
  type BaseUrl :: *
  data BaseUrl = BaseUrl {baseUrlScheme :: Scheme, baseUrlHost :: GHC.Base.String, baseUrlPort :: GHC.Types.Int, baseUrlPath :: GHC.Base.String}
  type ClientEnv :: *
  data ClientEnv = ClientEnv {manager :: http-client-0.7.17:Network.HTTP.Client.Types.Manager, baseUrl :: BaseUrl, cookieJar :: GHC.Maybe.Maybe (GHC.Conc.Sync.TVar http-client-0.7.17:Network.HTTP.Client.Types.CookieJar), makeClientRequest :: BaseUrl -> Servant.Client.Core.Request.Request -> GHC.Types.IO http-client-0.7.17:Network.HTTP.Client.Types.Request}
  type ClientError :: *
  data ClientError = FailureResponse (Servant.Client.Core.Request.RequestF () (BaseUrl, bytestring-0.11.5.3:Data.ByteString.Internal.Type.ByteString)) Response | DecodeFailure Data.Text.Internal.Text Response | UnsupportedContentType http-media-0.8.1.1:Network.HTTP.Media.MediaType.Internal.MediaType Response | InvalidContentTypeHeader Response | ConnectionError GHC.Exception.Type.SomeException
  type role ClientM nominal
  type ClientM :: * -> *
  newtype ClientM a = Servant.Client.Internal.HttpClient.ClientM {Servant.Client.Internal.HttpClient.unClientM :: Control.Monad.Trans.Reader.ReaderT ClientEnv (Control.Monad.Trans.Except.ExceptT ClientError GHC.Types.IO) a}
  type EmptyClient :: *
  data EmptyClient = EmptyClient
  type HasClient :: (* -> *) -> * -> Constraint
  class Servant.Client.Core.RunClient.RunClient m => HasClient m api where
    type Client :: (* -> *) -> * -> *
    type family Client m api
    clientWithRoute :: Data.Proxy.Proxy m -> Data.Proxy.Proxy api -> Servant.Client.Core.Request.Request -> Client m api
    hoistClientMonad :: forall (mon :: * -> *) (mon' :: * -> *). Data.Proxy.Proxy m -> Data.Proxy.Proxy api -> (forall x. mon x -> mon' x) -> Client mon api -> Client mon' api
    {-# MINIMAL clientWithRoute, hoistClientMonad #-}
    {-# MINIMAL clientWithRoute, hoistClientMonad #-}
  type InvalidBaseUrlException :: *
  newtype InvalidBaseUrlException = Servant.Client.Core.BaseUrl.InvalidBaseUrlException GHC.Base.String
  type Response :: *
  type Response = ResponseF Data.ByteString.Lazy.Internal.ByteString
  type ResponseF :: * -> *
  data ResponseF a = Response {responseStatusCode :: Network.HTTP.Types.Status.Status, responseHeaders :: Data.Sequence.Internal.Seq Network.HTTP.Types.Header.Header, responseHttpVersion :: Network.HTTP.Types.Version.HttpVersion, responseBody :: a}
  type Scheme :: *
  data Scheme = Http | Https
  type StreamingResponse :: *
  type StreamingResponse = ResponseF (Servant.API.Stream.SourceIO bytestring-0.11.5.3:Data.ByteString.Internal.Type.ByteString)
  client :: forall api. HasClient ClientM api => Data.Proxy.Proxy api -> Client ClientM api
  defaultMakeClientRequest :: BaseUrl -> Servant.Client.Core.Request.Request -> GHC.Types.IO http-client-0.7.17:Network.HTTP.Client.Types.Request
  foldMapUnion :: forall (c :: * -> Constraint) a (as :: [*]). Data.SOP.Constraint.All c as => Data.Proxy.Proxy c -> (forall x. c x => x -> a) -> Servant.API.UVerb.Union.Union as -> a
  hoistClient :: forall api (m :: * -> *) (n :: * -> *). HasClient ClientM api => Data.Proxy.Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api
  matchUnion :: forall a (as :: [*]). Servant.API.UVerb.Union.IsMember a as => Servant.API.UVerb.Union.Union as -> GHC.Maybe.Maybe a
  mkClientEnv :: http-client-0.7.17:Network.HTTP.Client.Types.Manager -> BaseUrl -> ClientEnv
  parseBaseUrl :: forall (m :: * -> *). Control.Monad.Catch.MonadThrow m => GHC.Base.String -> m BaseUrl
  runClientM :: forall a. ClientM a -> ClientEnv -> GHC.Types.IO (Data.Either.Either ClientError a)
  showBaseUrl :: BaseUrl -> GHC.Base.String

module Servant.Client.Internal.HttpClient where

-- ignored


module Servant.Client.Internal.HttpClient.Streaming where

-- ignored


module Servant.Client.Streaming where
  (//) :: forall a b. a -> (a -> b) -> b
  (/:) :: forall a b c. (a -> b -> c) -> b -> a -> c
  type role AsClientT phantom
  type AsClientT :: (* -> *) -> *
  data AsClientT m
  type BaseUrl :: *
  data BaseUrl = BaseUrl {baseUrlScheme :: Scheme, baseUrlHost :: GHC.Base.String, baseUrlPort :: GHC.Types.Int, baseUrlPath :: GHC.Base.String}
  type ClientEnv :: *
  data ClientEnv = ClientEnv {manager :: http-client-0.7.17:Network.HTTP.Client.Types.Manager, baseUrl :: BaseUrl, cookieJar :: GHC.Maybe.Maybe (GHC.Conc.Sync.TVar http-client-0.7.17:Network.HTTP.Client.Types.CookieJar), makeClientRequest :: BaseUrl -> Servant.Client.Core.Request.Request -> GHC.Types.IO http-client-0.7.17:Network.HTTP.Client.Types.Request}
  type ClientError :: *
  data ClientError = FailureResponse (Servant.Client.Core.Request.RequestF () (BaseUrl, bytestring-0.11.5.3:Data.ByteString.Internal.Type.ByteString)) Response | DecodeFailure Data.Text.Internal.Text Response | UnsupportedContentType http-media-0.8.1.1:Network.HTTP.Media.MediaType.Internal.MediaType Response | InvalidContentTypeHeader Response | ConnectionError GHC.Exception.Type.SomeException
  type role ClientM nominal
  type ClientM :: * -> *
  newtype ClientM a = Servant.Client.Internal.HttpClient.Streaming.ClientM {Servant.Client.Internal.HttpClient.Streaming.unClientM :: Control.Monad.Trans.Reader.ReaderT ClientEnv (Control.Monad.Trans.Except.ExceptT ClientError (Control.Monad.Codensity.Codensity GHC.Types.IO)) a}
  type EmptyClient :: *
  data EmptyClient = EmptyClient
  type HasClient :: (* -> *) -> * -> Constraint
  class Servant.Client.Core.RunClient.RunClient m => HasClient m api where
    type Client :: (* -> *) -> * -> *
    type family Client m api
    clientWithRoute :: Data.Proxy.Proxy m -> Data.Proxy.Proxy api -> Servant.Client.Core.Request.Request -> Client m api
    hoistClientMonad :: forall (mon :: * -> *) (mon' :: * -> *). Data.Proxy.Proxy m -> Data.Proxy.Proxy api -> (forall x. mon x -> mon' x) -> Client mon api -> Client mon' api
    {-# MINIMAL clientWithRoute, hoistClientMonad #-}
    {-# MINIMAL clientWithRoute, hoistClientMonad #-}
  type InvalidBaseUrlException :: *
  newtype InvalidBaseUrlException = Servant.Client.Core.BaseUrl.InvalidBaseUrlException GHC.Base.String
  type Response :: *
  type Response = ResponseF Data.ByteString.Lazy.Internal.ByteString
  type ResponseF :: * -> *
  data ResponseF a = Response {responseStatusCode :: Network.HTTP.Types.Status.Status, responseHeaders :: Data.Sequence.Internal.Seq Network.HTTP.Types.Header.Header, responseHttpVersion :: Network.HTTP.Types.Version.HttpVersion, responseBody :: a}
  type Scheme :: *
  data Scheme = Http | Https
  type StreamingResponse :: *
  type StreamingResponse = ResponseF (Servant.API.Stream.SourceIO bytestring-0.11.5.3:Data.ByteString.Internal.Type.ByteString)
  client :: forall api. HasClient ClientM api => Data.Proxy.Proxy api -> Client ClientM api
  defaultMakeClientRequest :: BaseUrl -> Servant.Client.Core.Request.Request -> GHC.Types.IO http-client-0.7.17:Network.HTTP.Client.Types.Request
  foldMapUnion :: forall (c :: * -> Constraint) a (as :: [*]). Data.SOP.Constraint.All c as => Data.Proxy.Proxy c -> (forall x. c x => x -> a) -> Servant.API.UVerb.Union.Union as -> a
  hoistClient :: forall api (m :: * -> *) (n :: * -> *). HasClient ClientM api => Data.Proxy.Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api
  matchUnion :: forall a (as :: [*]). Servant.API.UVerb.Union.IsMember a as => Servant.API.UVerb.Union.Union as -> GHC.Maybe.Maybe a
  mkClientEnv :: http-client-0.7.17:Network.HTTP.Client.Types.Manager -> BaseUrl -> ClientEnv
  parseBaseUrl :: forall (m :: * -> *). Control.Monad.Catch.MonadThrow m => GHC.Base.String -> m BaseUrl
  runClientM :: forall a. Control.DeepSeq.NFData a => ClientM a -> ClientEnv -> GHC.Types.IO (Data.Either.Either ClientError a)
  showBaseUrl :: BaseUrl -> GHC.Base.String
  withClientM :: forall a b. ClientM a -> ClientEnv -> (Data.Either.Either ClientError a -> GHC.Types.IO b) -> GHC.Types.IO b


-- Instances:
instance aeson-2.2.3.0:Data.Aeson.Types.FromJSON.FromJSON Servant.Client.Core.BaseUrl.BaseUrl -- Defined in ‘Servant.Client.Core.BaseUrl’
instance aeson-2.2.3.0:Data.Aeson.Types.FromJSON.FromJSONKey Servant.Client.Core.BaseUrl.BaseUrl -- Defined in ‘Servant.Client.Core.BaseUrl’
instance aeson-2.2.3.0:Data.Aeson.Types.ToJSON.ToJSON Servant.Client.Core.BaseUrl.BaseUrl -- Defined in ‘Servant.Client.Core.BaseUrl’
instance aeson-2.2.3.0:Data.Aeson.Types.ToJSON.ToJSONKey Servant.Client.Core.BaseUrl.BaseUrl -- Defined in ‘Servant.Client.Core.BaseUrl’
instance Control.Monad.IO.Class.MonadIO Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance Control.Monad.IO.Class.MonadIO Servant.Client.Internal.HttpClient.Streaming.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient.Streaming’
instance Data.Data.Data Servant.Client.Core.BaseUrl.BaseUrl -- Defined in ‘Servant.Client.Core.BaseUrl’
instance Data.Data.Data Servant.Client.Core.BaseUrl.Scheme -- Defined in ‘Servant.Client.Core.BaseUrl’
instance Data.Foldable.Foldable Servant.Client.Core.Response.ResponseF -- Defined in ‘Servant.Client.Core.Response’
instance Data.Traversable.Traversable Servant.Client.Core.Response.ResponseF -- Defined in ‘Servant.Client.Core.Response’
instance GHC.Base.Applicative Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance GHC.Base.Applicative Servant.Client.Internal.HttpClient.Streaming.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient.Streaming’
instance GHC.Base.Functor Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance GHC.Base.Functor Servant.Client.Core.Response.ResponseF -- Defined in ‘Servant.Client.Core.Response’
instance GHC.Base.Functor Servant.Client.Internal.HttpClient.Streaming.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient.Streaming’
instance GHC.Base.Monad Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance GHC.Base.Monad Servant.Client.Internal.HttpClient.Streaming.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient.Streaming’
instance GHC.Enum.Bounded Servant.Client.Core.HasClient.EmptyClient -- Defined in ‘Servant.Client.Core.HasClient’
instance GHC.Enum.Enum Servant.Client.Core.HasClient.EmptyClient -- Defined in ‘Servant.Client.Core.HasClient’
instance GHC.Exception.Type.Exception Servant.Client.Core.BaseUrl.InvalidBaseUrlException -- Defined in ‘Servant.Client.Core.BaseUrl’
instance GHC.Exception.Type.Exception Servant.Client.Core.ClientError.ClientError -- Defined in ‘Servant.Client.Core.ClientError’
instance GHC.Generics.Generic Servant.Client.Core.BaseUrl.BaseUrl -- Defined in ‘Servant.Client.Core.BaseUrl’
instance GHC.Generics.Generic Servant.Client.Core.BaseUrl.Scheme -- Defined in ‘Servant.Client.Core.BaseUrl’
instance forall a. GHC.Generics.Generic (Servant.Client.Internal.HttpClient.ClientM a) -- Defined in ‘Servant.Client.Internal.HttpClient’
instance GHC.Generics.Generic Servant.Client.Core.ClientError.ClientError -- Defined in ‘Servant.Client.Core.ClientError’
instance forall a. GHC.Generics.Generic (Servant.Client.Core.Response.ResponseF a) -- Defined in ‘Servant.Client.Core.Response’
instance forall a. GHC.Generics.Generic (Servant.Client.Internal.HttpClient.Streaming.ClientM a) -- Defined in ‘Servant.Client.Internal.HttpClient.Streaming’
instance GHC.Show.Show Servant.Client.Core.HasClient.ClientParseError -- Defined in ‘Servant.Client.Core.HasClient’
instance GHC.Show.Show Servant.Client.Core.HasClient.EmptyClient -- Defined in ‘Servant.Client.Core.HasClient’
instance GHC.Show.Show Servant.Client.Core.BaseUrl.BaseUrl -- Defined in ‘Servant.Client.Core.BaseUrl’
instance GHC.Show.Show Servant.Client.Core.BaseUrl.InvalidBaseUrlException -- Defined in ‘Servant.Client.Core.BaseUrl’
instance GHC.Show.Show Servant.Client.Core.BaseUrl.Scheme -- Defined in ‘Servant.Client.Core.BaseUrl’
instance GHC.Show.Show Servant.Client.Core.ClientError.ClientError -- Defined in ‘Servant.Client.Core.ClientError’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Servant.Client.Core.Response.ResponseF a) -- Defined in ‘Servant.Client.Core.Response’
instance Control.DeepSeq.NFData Servant.Client.Core.BaseUrl.BaseUrl -- Defined in ‘Servant.Client.Core.BaseUrl’
instance Control.DeepSeq.NFData Servant.Client.Core.ClientError.ClientError -- Defined in ‘Servant.Client.Core.ClientError’
instance forall a. Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Servant.Client.Core.Response.ResponseF a) -- Defined in ‘Servant.Client.Core.Response’
instance Control.Monad.Catch.MonadCatch Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance Control.Monad.Catch.MonadMask Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance Control.Monad.Catch.MonadThrow Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance GHC.Classes.Eq Servant.Client.Core.HasClient.ClientParseError -- Defined in ‘Servant.Client.Core.HasClient’
instance GHC.Classes.Eq Servant.Client.Core.HasClient.EmptyClient -- Defined in ‘Servant.Client.Core.HasClient’
instance GHC.Classes.Eq Servant.Client.Core.BaseUrl.BaseUrl -- Defined in ‘Servant.Client.Core.BaseUrl’
instance GHC.Classes.Eq Servant.Client.Core.BaseUrl.Scheme -- Defined in ‘Servant.Client.Core.BaseUrl’
instance GHC.Classes.Eq Servant.Client.Core.ClientError.ClientError -- Defined in ‘Servant.Client.Core.ClientError’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Servant.Client.Core.Response.ResponseF a) -- Defined in ‘Servant.Client.Core.Response’
instance GHC.Classes.Ord Servant.Client.Core.BaseUrl.BaseUrl -- Defined in ‘Servant.Client.Core.BaseUrl’
instance GHC.Classes.Ord Servant.Client.Core.BaseUrl.Scheme -- Defined in ‘Servant.Client.Core.BaseUrl’
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance Control.Monad.Error.Class.MonadError Servant.Client.Core.ClientError.ClientError Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance Control.Monad.Error.Class.MonadError Servant.Client.Core.ClientError.ClientError Servant.Client.Internal.HttpClient.Streaming.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient.Streaming’
instance Control.Monad.Reader.Class.MonadReader Servant.Client.Internal.HttpClient.ClientEnv Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance Control.Monad.Reader.Class.MonadReader Servant.Client.Internal.HttpClient.ClientEnv Servant.Client.Internal.HttpClient.Streaming.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient.Streaming’
instance Data.Functor.Alt.Alt Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance Data.Functor.Alt.Alt Servant.Client.Internal.HttpClient.Streaming.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient.Streaming’
instance forall (m :: * -> *). Servant.API.Generic.GenericMode (Servant.Client.Core.HasClient.AsClientT m) -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlapping] forall a (x :: a) (xs :: [a]). Servant.API.UVerb.Union.UElem x (x : xs) -- Defined in ‘Servant.API.UVerb.Union’
instance [overlapping] forall a (x :: a) (xs :: [a]) (x' :: a). Servant.API.UVerb.Union.UElem x xs => Servant.API.UVerb.Union.UElem x (x' : xs) -- Defined in ‘Servant.API.UVerb.Union’
instance forall (api :: * -> *) (m :: * -> *). Servant.Client.Core.HasClient.GClientConstraints api m => Servant.Client.Core.HasClient.GClient api m -- Defined in ‘Servant.Client.Core.HasClient’
instance forall (m :: * -> *) a b. (Servant.Client.Core.HasClient.HasClient m a, Servant.Client.Core.HasClient.HasClient m b) => Servant.Client.Core.HasClient.HasClient m (a Servant.API.Alternative.:<|> b) -- Defined in ‘Servant.Client.Core.HasClient’
instance forall (path :: GHC.Types.Symbol) (m :: * -> *) api. (GHC.TypeLits.KnownSymbol path, Servant.Client.Core.HasClient.HasClient m api) => Servant.Client.Core.HasClient.HasClient m (path Servant.API.Sub.:> api) -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlappable] forall k (m :: * -> *) (ty :: k) sub. (Servant.Client.Core.RunClient.RunClient m, (TypeError ...)) => Servant.Client.Core.HasClient.HasClient m (ty Servant.API.Sub.:> sub) -- Defined in ‘Servant.Client.Core.HasClient’
instance forall (m :: * -> *). Servant.Client.Core.RunClient.RunClient m => Servant.Client.Core.HasClient.HasClient m Servant.API.Empty.EmptyAPI -- Defined in ‘Servant.Client.Core.HasClient’
instance forall (api :: * -> *) (m :: * -> *). (forall (n :: * -> *). Servant.Client.Core.HasClient.GClient api n, Servant.Client.Core.HasClient.HasClient m (Servant.API.Generic.ToServantApi api), Servant.Client.Core.RunClient.RunClient m, Servant.API.TypeErrors.ErrorIfNoGeneric api) => Servant.Client.Core.HasClient.HasClient m (Servant.API.NamedRoutes.NamedRoutes api) -- Defined in ‘Servant.Client.Core.HasClient’
instance forall k1 (m :: * -> *) (method :: k1). (Servant.Client.Core.RunClient.RunClient m, Servant.API.Verbs.ReflectMethod method) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.NoContentVerb method) -- Defined in ‘Servant.Client.Core.HasClient’
instance forall (m :: * -> *). Servant.Client.Core.RunClient.RunClient m => Servant.Client.Core.HasClient.HasClient m Servant.API.Raw.Raw -- Defined in ‘Servant.Client.Core.HasClient’
instance forall (m :: * -> *). Servant.Client.Core.RunClient.RunClient m => Servant.Client.Core.HasClient.HasClient m Servant.API.Raw.RawM -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlappable] forall k1 (m :: * -> *) ct chunk (method :: k1) framing a (status :: GHC.TypeNats.Nat). (Servant.Client.Core.RunClient.RunStreamingClient m, Servant.API.ContentTypes.MimeUnrender ct chunk, Servant.API.Verbs.ReflectMethod method, Servant.API.Stream.FramingUnrender framing, Servant.API.Stream.FromSourceIO chunk a) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Stream.Stream method status framing ct a) -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlapping] forall k1 (m :: * -> *) ct chunk (method :: k1) framing a (hs :: [*]) (status :: GHC.TypeNats.Nat). (Servant.Client.Core.RunClient.RunStreamingClient m, Servant.API.ContentTypes.MimeUnrender ct chunk, Servant.API.Verbs.ReflectMethod method, Servant.API.Stream.FramingUnrender framing, Servant.API.Stream.FromSourceIO chunk a, Servant.API.ResponseHeaders.BuildHeadersTo hs) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Stream.Stream method status framing ct (Servant.API.ResponseHeaders.Headers hs a)) -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlapping] forall (m :: * -> *) (contentTypes :: [*]) contentType (otherContentTypes :: [*]) (as :: [*]) a (as' :: [*]) (method :: Network.HTTP.Types.Method.StdMethod).
                       (Servant.Client.Core.RunClient.RunClient m, contentTypes ~ (contentType : otherContentTypes), as ~ (a : as'), Servant.API.ContentTypes.AllMime contentTypes, Servant.API.Verbs.ReflectMethod method, Data.SOP.Constraint.All (Servant.Client.Core.HasClient.UnrenderResponse contentTypes) as, Data.SOP.Constraint.All Servant.API.UVerb.HasStatus as, Servant.API.UVerb.HasStatuses as', Servant.API.UVerb.Union.Unique (Servant.API.UVerb.Statuses as)) =>
                       Servant.Client.Core.HasClient.HasClient m (Servant.API.UVerb.UVerb method contentTypes as)
  -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlappable] forall k1 (m :: * -> *) ct a (method :: k1) (cts' :: [*]) (cts :: [*]) (status :: GHC.TypeNats.Nat). (Servant.Client.Core.RunClient.RunClient m, Servant.API.ContentTypes.MimeUnrender ct a, Servant.API.Verbs.ReflectMethod method, cts' ~ (ct : cts), GHC.TypeNats.KnownNat status) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts' a) -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlapping] forall k1 (m :: * -> *) (method :: k1) (status :: GHC.TypeNats.Nat) (cts :: [*]). (Servant.Client.Core.RunClient.RunClient m, Servant.API.Verbs.ReflectMethod method, GHC.TypeNats.KnownNat status) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts Servant.API.ContentTypes.NoContent) -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlapping] forall k1 (m :: * -> *) ct a (ls :: [*]) (status :: GHC.TypeNats.Nat) (method :: k1) (cts' :: [*]) (cts :: [*]). (Servant.Client.Core.RunClient.RunClient m, Servant.API.ContentTypes.MimeUnrender ct a, Servant.API.ResponseHeaders.BuildHeadersTo ls, GHC.TypeNats.KnownNat status, Servant.API.Verbs.ReflectMethod method, cts' ~ (ct : cts)) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts' (Servant.API.ResponseHeaders.Headers ls a)) -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlapping] forall k1 (m :: * -> *) (ls :: [*]) (method :: k1) (status :: GHC.TypeNats.Nat) (cts :: [*]). (Servant.Client.Core.RunClient.RunClient m, Servant.API.ResponseHeaders.BuildHeadersTo ls, Servant.API.Verbs.ReflectMethod method, GHC.TypeNats.KnownNat status) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts (Servant.API.ResponseHeaders.Headers ls Servant.API.ContentTypes.NoContent)) -- Defined in ‘Servant.Client.Core.HasClient’
instance forall (m :: * -> *) subapi (name :: GHC.Types.Symbol) (context :: [*]). Servant.Client.Core.HasClient.HasClient m subapi => Servant.Client.Core.HasClient.HasClient m (Servant.API.WithNamedContext.WithNamedContext name context subapi) -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlappable] forall (m :: * -> *) api. (Servant.Client.Core.RunClient.RunClient m, (TypeError ...)) => Servant.Client.Core.HasClient.HasClient m api -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlapping] forall (cts :: [*]) a (h :: [*]). (Servant.Client.Core.HasClient.UnrenderResponse cts a, Servant.API.ResponseHeaders.BuildHeadersTo h) => Servant.Client.Core.HasClient.UnrenderResponse cts (Servant.API.ResponseHeaders.Headers h a) -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlapping] forall (cts :: [*]) a (n :: GHC.TypeNats.Nat). Servant.Client.Core.HasClient.UnrenderResponse cts a => Servant.Client.Core.HasClient.UnrenderResponse cts (Servant.API.UVerb.WithStatus n a) -- Defined in ‘Servant.Client.Core.HasClient’
instance [overlappable] forall (cts :: [*]) a. Servant.API.ContentTypes.AllMimeUnrender cts a => Servant.Client.Core.HasClient.UnrenderResponse cts a -- Defined in ‘Servant.Client.Core.HasClient’
instance Servant.Client.Core.RunClient.RunClient Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance Servant.Client.Core.RunClient.RunClient Servant.Client.Internal.HttpClient.Streaming.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient.Streaming’
instance Servant.Client.Core.RunClient.RunStreamingClient Servant.Client.Internal.HttpClient.Streaming.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient.Streaming’
instance Language.Haskell.TH.Syntax.Lift Servant.Client.Core.BaseUrl.BaseUrl -- Defined in ‘Servant.Client.Core.BaseUrl’
instance Language.Haskell.TH.Syntax.Lift Servant.Client.Core.BaseUrl.Scheme -- Defined in ‘Servant.Client.Core.BaseUrl’
instance Control.Monad.Base.MonadBase GHC.Types.IO Servant.Client.Internal.HttpClient.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient’
instance Control.Monad.Base.MonadBase GHC.Types.IO Servant.Client.Internal.HttpClient.Streaming.ClientM -- Defined in ‘Servant.Client.Internal.HttpClient.Streaming’
